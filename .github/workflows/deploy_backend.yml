# \backend/.github/workflows/deploy_backend.yml
name: D√©ployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      DOMAIN: ${{ secrets.DOMAIN }}
      GIT_REPO_URL: ${{ secrets.GIT_REPO_URL }}
      REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}
      LOGS_DIR: backend/logs
      SERVER_LOG: server-${{ vars.ENV }}.log

    steps:
      # √âtape 0 - Configurer l'agent SSH global
      - name: 0 - Configurer l'agent SSH (globale)
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Cl√© SSH invalide." && exit 1)

      # √âtape 1 : Pr√©paration initiale
      - name: 1 - Pr√©paration initiale
        run: |
          echo "=== D√©but de la pr√©paration initiale ==="
          echo "Cr√©ation du r√©pertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "R√©pertoire de logs cr√©√© avec succ√®s."
          echo "=== Fin de la pr√©paration initiale ==="

      # √âtape 1.1 - Afficher les variables g√©n√©r√©es et valider leur pr√©sence
      - name: 1.1 - Afficher les variables g√©n√©r√©es
        run: |
          echo "[INFO] Affichage des variables g√©n√©r√©es : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET DOMAIN )
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done

      # √âtape 2 - R√©cup√©rer le d√©p√¥t Git
      - name: 2 - R√©cup√©rer le d√©p√¥t
        uses: actions/checkout@v3

      # √âtape 2.1 - V√©rification apr√®s checkout
      - name: 2.1 - V√©rification apr√®s checkout
        run: |
          echo "[INFO] V√©rification apr√®s le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable √† la racine. V√©rifiez la structure du d√©p√¥t." && exit 1
          fi

      # √âtape 2.1.1 - Configurer l'agent SSH pour le clonage
      - name: 2.1.1 - Configurer l'agent SSH
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          echo "=== √âtape 2.1.1 : Configuration de l'agent SSH ==="
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "[ERROR] Cl√© SSH invalide." && exit 1)
          echo "[SUCCESS] Agent SSH configur√© avec succ√®s."

      # √âtape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20.18.1"

      # √âtape 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
      - name: 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
        run: |
          echo "[INFO - 3.1] Cr√©ation du r√©pertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          echo "[INFO - 3.2] Installation des d√©pendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi
          echo "[INFO - 3.3] Validation des vuln√©rabilit√©s..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique √©chou√©. √Ä v√©rifier manuellement."
          }
          echo "[INFO - 3.4] Validation de l'arbre des d√©pendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de d√©pendances invalide d√©tect√©. R√©g√©n√©ration en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de d√©pendances valide."
          fi
          echo "[SUCCESS - 3.5] D√©pendances pr√™tes pour le d√©ploiement."

      - name: 4 - Copier le code backend sur le serveur
        run: |
          echo "üìÇ Cr√©ation d‚Äôun r√©pertoire temporaire avec le backend..."
          mkdir -p backend_sync
          rsync -av --exclude='.git' --exclude='node_modules' --exclude='logs' ./ backend_sync/

          echo "üöÄ Envoi du backend au serveur distant..."
          ssh -p $SSH_PORT -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no $SSH_USER@$SERVER_IP "mkdir -p $MOUNT_PATH"

          # üí• C'est cette ligne qui manquait
          rsync -av -e "ssh -p $SSH_PORT -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
            backend_sync/ $SSH_USER@$SERVER_IP:$MOUNT_PATH/

          echo "üßº Nettoyage du r√©pertoire temporaire local..."
          rm -rf backend_sync

          echo "‚úÖ Backend copi√© avec succ√®s vers $MOUNT_PATH sur le serveur."

      # √âtape 6 - Configuration du conteneur PostgreSQL
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          echo "=== √âtape 6 : Configuration du conteneur PostgreSQL ==="

          # Sous-√©tape 6.1 : Cr√©er un fichier temporaire contenant les variables n√©cessaires
          echo "[INFO - Sous-√©tape 6.1] Cr√©ation du fichier temporaire contenant les variables..."
          cat <<EOT > /tmp/env_vars.sh
          ENV=$ENV
          NETWORK=$NETWORK
          POSTGRES_VOLUME=$POSTGRES_VOLUME
          POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME
          DB_USERNAME=$DB_USERNAME
          DB_PASSWORD=$DB_PASSWORD
          DB_NAME=$DB_NAME
          DB_PORT_INT=$DB_PORT_INT
          DB_PORT_EXT=$DB_PORT_EXT
          EOT

          # V√©rification de la cr√©ation du fichier temporaire
          if [ ! -f /tmp/env_vars.sh ]; then
            echo "[ERROR] √âchec de la cr√©ation du fichier temporaire /tmp/env_vars.sh." >&2
            exit 1
          fi

          # Sous-√©tape 6.2 : Copier le fichier temporaire vers le serveur distant
          echo "[INFO - Sous-√©tape 6.2] Envoi du fichier temporaire contenant les variables au serveur distant..."
          scp -P "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no /tmp/env_vars.sh "$SSH_USER@$SERVER_IP:/tmp/env_vars.sh"

          # Sous-√©tape 6.3 : Connexion SSH et ex√©cution des commandes sur le serveur distant
          ssh -p "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" << 'EOF'
          set -e

          # Charger les variables depuis le fichier temporaire
          source /tmp/env_vars.sh

          # V√©rifier/cr√©er le r√©seau Docker
          if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
            docker network create "$NETWORK"
          fi

          # V√©rifier/cr√©er le volume Docker
          if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
            docker volume create "$POSTGRES_VOLUME"
          fi

          # Arr√™ter et supprimer le conteneur PostgreSQL existant
          if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
            docker stop "$POSTGRES_CONTAINER_NAME" || true
            docker rm "$POSTGRES_CONTAINER_NAME" || true
          fi

          # Lancer un nouveau conteneur PostgreSQL
          docker run -d --name "$POSTGRES_CONTAINER_NAME" \
            --network "$NETWORK" \
            -e POSTGRES_USER="$DB_USERNAME" \
            -e POSTGRES_PASSWORD="$DB_PASSWORD" \
            -e POSTGRES_DB="$DB_NAME" \
            -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
            -p "$DB_PORT_EXT:$DB_PORT_INT" \
            postgres:13

          # V√©rifier que PostgreSQL est pr√™t
          for i in {1..10}; do
            if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U "$DB_USERNAME" -d "$DB_NAME"; then
              echo "[INFO] PostgreSQL est pr√™t."
              break
            else
              echo "[INFO] En attente... (tentative $i/10)"
              sleep 5
            fi
          done

          # V√©rifier/cr√©er le r√¥le "postgres"
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='postgres';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          fi

          # V√©rifier/cr√©er la base de donn√©es
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USERNAME;"
          fi

          echo "[INFO] Configuration de PostgreSQL termin√©e avec succ√®s."
          EOF

          # Nettoyer le fichier temporaire local
          rm -f /tmp/env_vars.sh

      # √âtape 7 - Cr√©ation de la base de donn√©es et des utilisateurs
      - name: 7 - Cr√©ation de la base de donn√©es et des utilisateurs
        run: |
          echo "=== √âtape 7 : Cr√©ation de la base de donn√©es et des utilisateurs ==="

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - √âtape 7] Cr√©ation des utilisateurs et de la base de donn√©es...'

            # Assurez-vous que le r√©pertoire des logs existe
            LOG_DIR=\$(dirname "$LOG_FILE")
            mkdir -p "\$LOG_DIR"
            echo '[INFO] R√©pertoire des logs v√©rifi√©/cr√©√© : \$LOG_DIR' | tee -a "$LOG_FILE"

            # V√©rification et cr√©ation du r√¥le si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] R√¥le cr√©√© : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # V√©rification et cr√©ation de la base de donn√©es si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de donn√©es cr√©√©e : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] √âtape 7 termin√©e avec succ√®s.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - D√©ployer le conteneur Backend (build + d√©marrage)
        run: |
          echo "=== √âtape 8.0 : D√©ploiement du backend ==="

          # 8.1 - Construction de DATABASE_URL
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT_INT}/${DB_NAME}"
          echo "[INFO - 8.1] DATABASE_URL construit : $DATABASE_URL"

          # 8.2 - Connexion SSH et d√©ploiement
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" \
          "ENV='$ENV' DATABASE_URL='$DATABASE_URL' JWT_SECRET='$JWT_SECRET' BACKEND_PORT='$BACKEND_PORT' MOUNT_PATH='$MOUNT_PATH' POSTGRES_CONTAINER_NAME='$POSTGRES_CONTAINER_NAME' DB_USERNAME='$DB_USERNAME' DB_NAME='$DB_NAME' DB_HOST='$DB_HOST' DB_PORT_INT='$DB_PORT_INT' CONTAINER_NAME='$CONTAINER_NAME' NETWORK='$NETWORK' DOCKER_NAME='$DOCKER_NAME' DB_PASSWORD='$DB_PASSWORD' REACT_APP_API_URL='$REACT_APP_API_URL' bash -s" << 'EOF'

            set -e
            echo "=== √âtape 8.2 : D√©ploiement sur le serveur ==="

            # 8.2.1 - V√©rification des variables d'environnement
            echo "[INFO - 8.2.1] V√©rification des variables..."
            REQUIRED_VARS=(ENV DATABASE_URL JWT_SECRET BACKEND_PORT MOUNT_PATH DB_NAME DB_USERNAME DB_PASSWORD CONTAINER_NAME NETWORK)
            for VAR in "${REQUIRED_VARS[@]}"; do
              VALUE=$(eval echo "\$$VAR")
              if [ -z "$VALUE" ]; then
                echo "[ERROR] ‚ùå La variable $VAR est manquante." >&2
                exit 1
              fi
              echo "[OK] $VAR=$VALUE"
            done

            # 8.2.2 - G√©n√©ration du fichier .env
            echo "[INFO - 8.2.2] Cr√©ation du fichier .env..."
            cat <<EOT > "$MOUNT_PATH/.env"
            DATABASE_URL=$DATABASE_URL
            NODE_ENV=$ENV
            APP_ENV=$ENV
            APP_NAME=alxmultimedia_backend
            JWT_SECRET=$JWT_SECRET
            SERVER_PORT=$BACKEND_PORT
            REACT_APP_API_URL=$REACT_APP_API_URL
            TRUST_PROXY=1
            LOG_LEVEL=info
            ENABLE_CACHE=false
            ADMIN_TEST_TOKEN=
          EOT

            # 8.2.3 - Nettoyage des logs
            echo "[INFO - 8.2.3] Nettoyage des anciens logs..."
            mkdir -p "$MOUNT_PATH/logs"
            rm -f "$MOUNT_PATH/logs/*" || echo "[WARNING] Rien √† supprimer."
            find "$MOUNT_PATH/logs/" -type f -name "*.log" -mtime +7 -exec rm -f {} \;

            # 8.3 - Suppression de l'ancien conteneur
            echo "[INFO - 8.3] Suppression de l'ancien conteneur..."
            if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
              docker stop "$CONTAINER_NAME" || true
              docker rm "$CONTAINER_NAME" || true
            fi

            # 8.4 - D√©marrage du nouveau conteneur vide
            echo "[INFO - 8.4] D√©marrage d‚Äôun conteneur temporaire..."
            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH:/app" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "127.0.0.1:$BACKEND_PORT:$BACKEND_PORT" \
              node:20 \
              tail -f /dev/null

            # 8.5 - Installation des d√©pendances
            echo "[INFO - 8.5] Installation des d√©pendances..."

            # 8.5.1 - NPM (backend)
            docker exec "$CONTAINER_NAME" npm install --omit=dev --loglevel=warn
            docker exec "$CONTAINER_NAME" npm install node-fetch@2 --loglevel=warn

            # 8.5.2 - Paquets syst√®me (y compris psql)
            docker exec "$CONTAINER_NAME" apt-get update
            docker exec "$CONTAINER_NAME" apt-get install -y wget net-tools curl tzdata postgresql-client

            # 8.5.3 - Fuseau horaire (pour logs coh√©rents)
            docker exec "$CONTAINER_NAME" ln -sf /usr/share/zoneinfo/America/Montreal /etc/localtime
            docker exec "$CONTAINER_NAME" dpkg-reconfigure -f noninteractive tzdata

            # 8.5.4 - Test rapide de psql
            echo "[INFO - 8.5.4] V√©rification de l'installation de psql..."
            docker exec "$CONTAINER_NAME" psql --version || {
              echo "[ERROR - 8.5.4] ‚ùå psql n'est pas install√© correctement dans le conteneur."
              exit 1
            }

            # 8.6.3 - Copie forc√©e du schema.prisma local dans le conteneur
            echo "[INFO - 8.6.3] V√©rification et copie du fichier schema.prisma dans le conteneur..."

            # V√©rifie que le fichier existe localement (sur le serveur)
            if [ ! -f "$MOUNT_PATH/prisma/schema.prisma" ]; then
              echo "[ERROR] ‚ùå Fichier $MOUNT_PATH/prisma/schema.prisma introuvable." >&2
              echo "[DEBUG] Contenu du dossier $MOUNT_PATH/prisma :"
              ls -la "$MOUNT_PATH/prisma" || echo "[‚ùå] Dossier inexistant ou vide."
              exit 3
            fi

            # Copie vers le conteneur
            docker cp "$MOUNT_PATH/prisma/schema.prisma" "$CONTAINER_NAME:/app/prisma/schema.prisma"
            echo "[OK] ‚úÖ Fichier schema.prisma copi√© dans le conteneur."

            # Cr√©e le dossier logs s'il n'existe pas
            mkdir -p "$MOUNT_PATH/logs"

            env_short="d"
            if [ "$ENV" = "prod" ]; then
              env_short="p"
            fi

            # Affiche le contenu du dossier pour v√©rification et le log vers logs/$SERVER_LOG
            docker exec "$CONTAINER_NAME" ls -la /app/prisma | tee -a "$MOUNT_PATH/logs/$SERVER_LOG"


            # 8.6.4 - Prisma generate et npm build
            echo "[INFO - 8.6.4] Prisma generate et npm build..."
            docker exec "$CONTAINER_NAME" npx prisma generate
            docker exec "$CONTAINER_NAME" npm run build || echo "[INFO] Aucun build requis"

            # 8.6.5 - Lancement de la migration automatique Prisma (migrate_auto.sh)
            echo "[INFO - 8.6.5] Lancement de migrate_auto.sh..."

            # V√©rifier la pr√©sence du script dans le conteneur
            if ! docker exec "$CONTAINER_NAME" test -f ./migrate_auto.sh; then
              echo "[ERROR] ‚ùå migrate_auto.sh introuvable dans le conteneur." >&2
              echo "[INFO] Contenu du dossier courant dans le conteneur :"
              docker exec "$CONTAINER_NAME" ls -la
              exit 1
            fi

            # Lancer le script et intercepter les erreurs
            env_short="d"
            if [ "$ENV" = "prod" ]; then
              env_short="p"
            fi
            if ! docker exec "$CONTAINER_NAME" sh ./migrate_auto.sh; then
              echo "[ERROR] ‚ùå √âchec de l'ex√©cution du script migrate_auto.sh"
              echo "[LOGS] üîç Derni√®res lignes de logs ($SERVER_LOG) :"
              docker exec "$CONTAINER_NAME" tail -n 50 logs/$SERVER_LOG || echo "[INFO] Pas de logs trouv√©s."

              echo "[INFO] üìÑ Tentative d'affichage du fichier generated_migration.sql :"
              docker exec "$CONTAINER_NAME" cat prisma/generated_migration.sql || echo "[INFO] Aucun fichier SQL g√©n√©r√©."

              echo "[INFO] üîç Pensez √† v√©rifier les erreurs li√©es √† des conflits de sch√©ma existant."
              echo "‚ö†Ô∏è Diff √©chou√© ‚ûú probablement aucun changement. On continue."
            fi

            echo "[SUCCESS] ‚úÖ migrate_auto.sh ex√©cut√© avec succ√®s."

            # 8.7 - Connexion DB (pr√©-migration)
            echo "[INFO - 8.7] Test de connexion DB..."
            docker exec "$CONTAINER_NAME" node /app/tests/testDbConnection.js    


            # 8.9 - Backup post-migration
            echo "[INFO - 8.9] Backup de la base apr√®s migration..."
            BACKUP_DIR="$(dirname "$MOUNT_PATH")/backup_bd"
            mkdir -p "$BACKUP_DIR"
            BACKUP_FILE="$BACKUP_DIR/backup_after_migrate_$(date +%Y%m%d%H%M%S).sql"
            docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" -d "$DB_NAME" > "$BACKUP_FILE"
            sleep 30

            # 8.10 - Lancement du serveur backend
            echo "[INFO - 8.10] D√©marrage du backend..."
            docker exec -d "$CONTAINER_NAME" npm start           

            # 8.11 - V√©rification endpoint /health
            echo "[INFO - 8.11] V√©rification du endpoint /health sur port $BACKEND_PORT..."

            for i in {1..180}; do
              if docker exec "$CONTAINER_NAME" curl -sSf "http://localhost:$BACKEND_PORT/health" > /dev/null; then
                echo "[OK] ‚úÖ /health a r√©pondu correctement (tentative $i)"
                break
              fi
              echo "[WAIT] /health pas encore disponible (tentative $i/180)..."
              sleep 1
            done

            # Test final : si au bout de 180 sec c'est toujours inaccessible, on arr√™te tout
            env_short="d"
            if [ "$ENV" = "prod" ]; then
              env_short="p"
            fi
            if ! docker exec "$CONTAINER_NAME" curl -sSf "http://localhost:$BACKEND_PORT/health" > /dev/null; then
              echo "[ERROR] ‚ùå /health n‚Äôa pas r√©pondu apr√®s 180 secondes."
              docker exec "$CONTAINER_NAME" tail -n 50 logs/$SERVER_LOG
              exit 7
            fi

            # 8.12 - Tests post-d√©ploiement
            echo "[INFO - 8.12] Lancement des tests automatis√©s post-d√©ploiement..."

            if [ "$ENV" = "dev" ]; then
              echo "[INFO] Mode d√©veloppement - testComplet.js --debug"

              # 8.12.1 - G√©n√©rer le ADMIN_TEST_TOKEN
              echo "[INFO - 8.12.1] G√©n√©ration du ADMIN_TEST_TOKEN pour les tests..."
              ADMIN_TEST_TOKEN=$(docker exec "$CONTAINER_NAME" node /app/scripts/dev-only/generateAdminToken.js | tail -n 1)

              if [ -z "$ADMIN_TEST_TOKEN" ]; then
                echo "[ERROR] ‚ùå √âchec g√©n√©ration ADMIN_TEST_TOKEN."
                exit 1
              fi

              echo "[OK] ‚úÖ ADMIN_TEST_TOKEN g√©n√©r√©."

              # üõ† 8.12.1.1 - Remplacer proprement dans .env
              echo "[INFO - 8.12.1.1] Mise √† jour de /app/.env dans le conteneur..."
              docker exec "$CONTAINER_NAME" bash -c "
                sed -i '/^ADMIN_TEST_TOKEN=/d' /app/.env && \
                echo 'ADMIN_TEST_TOKEN=$ADMIN_TEST_TOKEN' >> /app/.env
              " || {
                echo "[ERROR] ‚ùå Impossible de mettre √† jour ADMIN_TEST_TOKEN dans /app/.env"
                exit 1
              }

              # üõ† 8.12.1.2 - Copier .env corrig√© du conteneur vers le serveur
              echo "[INFO - 8.12.1.2] Copie du .env corrig√© vers le serveur ($MOUNT_PATH/.env)..."
              docker cp "$CONTAINER_NAME:/app/.env" "$MOUNT_PATH/.env" || {
                echo "[ERROR] ‚ùå Impossible de copier le .env depuis le conteneur."
                exit 1
              }
              
              # 8.12.1.3 - Gestion automatique des utilisateurs de test (environnement DEV uniquement)
              if [ "$ENV" = "dev" ]; then
                echo "[INFO - 8.12.1.3] Ex√©cution de manageTestUsers.js pour pr√©parer les utilisateurs de test..."
                docker exec "$CONTAINER_NAME" node /app/scripts/dev-only/manageTestUsers.js all || {
                  echo "[WARN] ‚ö†Ô∏è La cr√©ation/mise √† jour des utilisateurs de test a √©chou√©."
                }
              fi

              # 8.12.2 - Lancer les tests backend avec ADMIN_TEST_TOKEN
              echo "[INFO - 8.12.2] Lancement des tests automatis√©s avec token..."
              docker exec -e ADMIN_TEST_TOKEN="$ADMIN_TEST_TOKEN" "$CONTAINER_NAME" node /app/tests/testComplet.js --debug

            else
              echo "[INFO] Mode production - testComplet.js"
              docker exec "$CONTAINER_NAME" node /app/tests/testComplet.js
            fi

            # 8.12.4 - Liste des tables existantes dans la base de donn√©es...
            echo "[INFO - 8.12.4] Liste des tables existantes dans la base de donn√©es..."

            echo "Info variables :"
            echo "ENV=$ENV"
            echo "CONTAINER_NAME=$CONTAINER_NAME"
            echo "DB_PASSWORD=$DB_PASSWORD"            
            echo "DB_HOST=$DB_HOST"
            echo "DB_PORT_INT=$DB_PORT_INT" 
            echo "DB_USERNAME=$DB_USERNAME"
            echo "DB_NAME=$DB_NAME"

              if [ -z "$DB_HOST" ] || [ -z "$DB_PORT_INT" ]; then
                echo "[WARN] ‚ùå DB_HOST ou DB_PORT_INT non d√©fini. Impossible d'ex√©cuter psql."
                exit 0
              fi

              echo "üìã Tables dans la base $DB_NAME :"
              docker exec "$CONTAINER_NAME" bash -c "PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT_INT" -U "$DB_USERNAME" -d "$DB_NAME" -c '\dt'" || echo "[WARN] ‚ùå Impossible de lister les tables avec \dt"

              echo "üì¶ Toutes les relations (bonus) :"
              docker exec "$CONTAINER_NAME" bash -c "PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT_INT" -U "$DB_USERNAME" -d "$DB_NAME" -c '\d+'" || echo "[WARN] ‚ùå Impossible d‚Äôafficher les relations."


            # 8.13 - Nettoyage final
            echo "[INFO - 8.13] Suppression des fichiers temporaires..."
            rm -f /tmp/git_id_rsa /tmp/env_vars.sh

            echo "[SUCCESS ‚úÖ] √âtape 8 termin√©e avec succ√®s."
          EOF

      # √âtape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # √âtape 10 - Nettoyage des fichiers temporaires
      - name: 10 - Nettoyage des fichiers temporaires
        run: rm -f /tmp/git_id_rsa /tmp/env_vars.sh || true
