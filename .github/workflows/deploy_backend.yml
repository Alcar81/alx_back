name: Déployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}     
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      # Étape 1 : Préparation initiale
      - name: 1 - Préparation initiale
        run: |
          echo "=== Début de la préparation initiale ==="
          echo "Création du répertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de créer le répertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "Répertoire de logs créé avec succès."
          echo "=== Fin de la préparation initiale ==="  
      # Étape 1.1 - Afficher les variables générées et valider leur présence
      - name: 1.1 - Afficher les variables générées
        run: |
          echo "[INFO] Affichage des variables générées : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET)
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done
      # Étape 2 - Récupérer le dépôt Git
      - name: 2 - Récupérer le dépôt
        uses: actions/checkout@v3
        

      # Étape 2.1 - Vérification après checkout
      - name: 2.1 - Vérification après checkout
        run: |
          echo "[INFO] Vérification après le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable à la racine. Vérifiez la structure du dépôt." && exit 1
          fi
      # Étape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.1'

      # Étape 3 - Installer les dépendances et valider l'arbre de dépendances
      - name: 3 - Installer les dépendances et valider l'arbre de dépendances
        run: |
          echo "[INFO - 3.1] Création du répertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de créer le répertoire des logs." && exit 1)
          echo "[INFO - 3.2] Installation des dépendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi
          echo "[INFO - 3.3] Validation des vulnérabilités..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique échoué. À vérifier manuellement."
          }
          echo "[INFO - 3.4] Validation de l'arbre des dépendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de dépendances invalide détecté. Régénération en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de dépendances valide."
          fi
          echo "[SUCCESS - 3.5] Dépendances prêtes pour le build Docker."
      # Étape 4 - Construire l'image Docker pour le backend
      - name: 4 - Construire l'image Docker
        run: |
          echo "[INFO - 4.1] Nettoyage des images Docker inutilisées..."
          docker image prune -f || (echo "[ERROR - 4.1] Impossible de nettoyer les images Docker." && exit 1)
          echo "[INFO - 4.2] Construction de l'image Docker pour le backend..."
          docker build -t $DOCKER_NAME -f Dockerfile.backend . | tee -a logs/backend_deploy.log || exit 1
          echo "[INFO - 4.3] Validation du build Docker..."
          docker images $DOCKER_NAME || (echo "[ERROR - 4.3] L'image Docker $DOCKER_NAME n'a pas été construite avec succès." && exit 1)
          echo "[SUCCESS - 4.4] Image Docker construite avec succès : $DOCKER_NAME."
        
      # Étape 5 - Démarrer l'agent SSH et ajouter la clé 
      - name: 5 - Démarrer l'agent SSH et ajouter la clé
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Clé SSH invalide." && exit 1)
        
      # Étape 6 - Configuration du conteneur PostgreSQL      
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          echo "=== Étape 6 : Configuration du conteneur PostgreSQL ==="

          # Sous-étape 6.1 : Créer un fichier temporaire contenant les variables nécessaires
          echo "[INFO - Sous-étape 6.1] Création du fichier temporaire contenant les variables..."
          cat <<EOT > /tmp/env_vars.sh
          ENV=$ENV
          NETWORK=$NETWORK
          POSTGRES_VOLUME=$POSTGRES_VOLUME
          POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME
          DB_USERNAME=$DB_USERNAME
          DB_PASSWORD=$DB_PASSWORD
          DB_NAME=$DB_NAME
          DB_PORT_INT=$DB_PORT_INT
          DB_PORT_EXT=$DB_PORT_EXT
          EOT

          # Vérification de la création du fichier temporaire
          if [ ! -f /tmp/env_vars.sh ]; then
            echo "[ERROR] Échec de la création du fichier temporaire /tmp/env_vars.sh." >&2
            exit 1
          fi

          # Sous-étape 6.2 : Copier le fichier temporaire vers le serveur distant
          echo "[INFO - Sous-étape 6.2] Envoi du fichier temporaire contenant les variables au serveur distant..."
          scp -P "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no /tmp/env_vars.sh "$SSH_USER@$SERVER_IP:/tmp/env_vars.sh"

          # Sous-étape 6.3 : Connexion SSH et exécution des commandes sur le serveur distant
          ssh -p "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" << 'EOF'
          set -e

          # Sous-étape 6.3.1 : Charger les variables depuis le fichier temporaire
          echo "[INFO - Sous-étape 6.3.1] Chargement des variables depuis le fichier temporaire..."
          if [ -f /tmp/env_vars.sh ]; then
            source /tmp/env_vars.sh
          else
            echo "[ERROR] Le fichier /tmp/env_vars.sh est introuvable." >&2
            exit 1
          fi

          # Sous-étape 6.3.2 : Vérification des variables chargées
          echo "[INFO - Sous-étape 6.3.2] Vérification des variables chargées..."
          MANDATORY_VARS=(ENV NETWORK POSTGRES_VOLUME POSTGRES_CONTAINER_NAME DB_USERNAME DB_PASSWORD DB_NAME DB_PORT_INT DB_PORT_EXT)
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "\${!VAR}" ]; then
              echo "[ERROR] La variable \$VAR est manquante ou vide." >&2
              exit 1
            fi
            echo "[INFO] \$VAR=\${!VAR}"
          done

          # Sous-étape 6.3.3 : Vérifier et créer le réseau Docker
          echo "[INFO - Sous-étape 6.3.3] Vérification/création du réseau Docker..."
          if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
            docker network create "$NETWORK" || { echo "[ERROR] Impossible de créer le réseau Docker."; exit 1; }
          else
            echo "[INFO] Réseau Docker déjà existant : $NETWORK"
          fi

          # Sous-étape 6.3.4 : Vérifier et créer le volume Docker
          echo "[INFO - Sous-étape 6.3.4] Vérification/création du volume Docker..."
          if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
            docker volume create "$POSTGRES_VOLUME" || { echo "[ERROR] Impossible de créer le volume Docker."; exit 1; }
          else
            echo "[INFO] Volume Docker déjà existant : $POSTGRES_VOLUME"
          fi

          # Sous-étape 6.3.5 : Arrêter et supprimer le conteneur PostgreSQL existant
          echo "[INFO - Sous-étape 6.3.5] Arrêt/suppression du conteneur PostgreSQL existant..."
          if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
            docker stop "$POSTGRES_CONTAINER_NAME" || echo "[WARNING] Échec de l'arrêt du conteneur."
            docker rm "$POSTGRES_CONTAINER_NAME" || echo "[WARNING] Échec de la suppression du conteneur."
          fi

          # Sous-étape 6.3.6 : Lancer un nouveau conteneur PostgreSQL
          echo "[INFO - Sous-étape 6.3.6] Lancement du conteneur PostgreSQL..."
          docker run -d --name "$POSTGRES_CONTAINER_NAME" \
            --network "$NETWORK" \
            -e POSTGRES_USER="$DB_USERNAME" \
            -e POSTGRES_PASSWORD="$DB_PASSWORD" \
            -e POSTGRES_DB="$DB_NAME" \
            -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
            -p "$DB_PORT_EXT:$DB_PORT_INT" \
            postgres:13 || { echo "[ERROR] Échec du lancement du conteneur PostgreSQL."; exit 1; }

          # Sous-étape 6.3.7 : Vérification finale que PostgreSQL est prêt
          echo "[INFO - Sous-étape 6.3.7] Vérification que PostgreSQL est prêt..."
          for i in {1..10}; do
            if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U postgres -d postgres; then
              echo "[INFO] PostgreSQL est prêt."
              break
            else
              echo "[INFO] En attente... (tentative $i/10)"
              sleep 5
            fi
          done

          if [ "$i" -eq 10 ]; then
            echo "[ERROR] PostgreSQL n'a pas démarré après 10 tentatives." >&2
            exit 1
          fi

          # Étape 6.3.7.0 : Création du rôle si nécessaire
          echo "[INFO - Sous-étape 6.3.7.0] Vérification/création du rôle utilisateur..."
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || \
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE $DB_USERNAME WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          echo "[INFO] Rôle utilisateur '$DB_USERNAME' vérifié/créé avec succès."

          # Étape 6.3.7.1 - Création de la base de données si elle n'existe pas
          echo '[INFO - Sous-étape 6.3.7.1] Vérification/création de la base de données...'
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USERNAME;"
          echo "[INFO] Base de données '$DB_NAME' vérifiée/créée avec succès."

          # Sous-étape 6.3.8 : Vérification et création du rôle postgres
          echo "[INFO - Sous-étape 6.3.8] Vérification du rôle 'postgres'..."
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='postgres';" | grep -q 1; then
            echo "[INFO] Création du rôle 'postgres'..."
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          else
            echo "[INFO] Le rôle 'postgres' existe déjà."
          fi

          # Sous-étape 6.3.9 : Ajout des vérifications supplémentaires après création des rôles
          echo "[INFO - Sous-étape 6.3.9] Vérifications supplémentaires après la création des rôles..."
          docker inspect "$POSTGRES_CONTAINER_NAME" | grep -A 10 "Env"
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c '\l'
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c '\du'
          docker logs "$POSTGRES_CONTAINER_NAME"

          # Suppression du fichier temporaire
          echo "[INFO - Sous-étape 6.3.10] Suppression du fichier temporaire..."
          rm -f /tmp/env_vars.sh      
          EOF

          # Sous-étape 6.4 : Nettoyer le fichier temporaire local
          echo "[INFO - 6.4] Suppression du fichier temporaire local..."
          rm -f /tmp/env_vars.sh

      # Étape 7 - Création de la base de données et des utilisateurs
      - name: 7 - Création de la base de données et des utilisateurs
        run: |
          echo "=== Étape 7 : Création de la base de données et des utilisateurs ==="

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - Étape 7] Création des utilisateurs et de la base de données...' | tee -a "$LOG_FILE"
            
            # Vérification et création du rôle si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] Rôle créé : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # Vérification et création de la base de données si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de données créée : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] Étape 7 terminée avec succès.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - Déployer le conteneur Backend
        run: |
          echo "=== Étape 8 : Déploiement du backend ==="
          # Construction explicite de DATABASE_URL avant SSH
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT_INT}/${DB_NAME}"
          echo "[INFO] DATABASE_URL construit : $DATABASE_URL"

          # Exécution de la commande SSH
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e

            # Sous-étape 8.0 : Vérification des variables chargées
            echo "[INFO - Sous-étape 8.0] Vérification des variables chargées..."
            MANDATORY_VARS=(ENV DATABASE_URL JWT_SECRET BACKEND_PORT)
            for VAR in "${MANDATORY_VARS[@]}"; do
              VALUE=$(eval echo "\$$VAR")
              if [ -z "\$VALUE" ]; then
                echo "[ERROR] La variable \$VAR est manquante ou vide." >&2
                exit 1
              fi
              echo "[INFO] \$VAR=\$VALUE"
            done

            # Étape 8.1 - Création d’un fichier temporaire pour les variables
            echo '[INFO - Étape 8.1] Création d’un fichier temporaire avec les variables...'
            cat <<EOT > /tmp/env_vars_backend.sh
          DATABASE_URL=${DATABASE_URL}
          NODE_ENV=${ENV}
          JWT_SECRET=${JWT_SECRET}
          SERVER_PORT=${BACKEND_PORT}
          EOT

            # Étape 8.2 - Charger les variables et créer le fichier .env
            source /tmp/env_vars_backend.sh
            cat <<EOT > "$MOUNT_PATH/.env"
          DATABASE_URL=\$DATABASE_URL
          NODE_ENV=\$NODE_ENV
          JWT_SECRET=\$JWT_SECRET
          SERVER_PORT=\$SERVER_PORT
          EOT
          
            # Vérification de la création du fichier temporaire
            if [ -f /tmp/env_vars_backend.sh ]; then
              echo '[INFO] Fichier temporaire créé avec succès.'
            else
              echo '[ERROR] Échec de la création du fichier temporaire.' >&2
              exit 1
            fi
      
            # Étape 8.2 - Charger les variables et créer le fichier .env
            echo '[INFO - Étape 8.2] Chargement des variables depuis le fichier temporaire...'
            source /tmp/env_vars_backend.sh
      
            echo '[INFO - Étape 8.3] Création du fichier .env...'
            cat <<EOT > "$MOUNT_PATH/.env"
          DATABASE_URL=\$DATABASE_URL
          NODE_ENV=\$NODE_ENV
          JWT_SECRET=\$JWT_SECRET
          SERVER_PORT=\$SERVER_PORT
          EOT
          
              # Étape 8.4 - Vérifier la création du fichier .env
              if [ -f "$MOUNT_PATH/.env" ]; then
                echo '[INFO] Fichier .env créé avec succès.'
              else
                echo '[ERROR] Échec de la création du fichier .env.' >&2
                exit 1
              fi
        
              # Étape 8.5 - Suppression de l'ancien conteneur
              echo '[INFO - Étape 8.5] Suppression de l’ancien conteneur...'
              if docker ps -a --filter "name=$CONTAINER_NAME" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
                docker stop "$CONTAINER_NAME" || echo '[WARNING] Échec de l’arrêt du conteneur.'
                docker rm "$CONTAINER_NAME" || echo '[WARNING] Échec de la suppression du conteneur.'
              fi
        
            # Étape 8.6 - Lancement du nouveau conteneur backend
            echo '[INFO - Étape 8.6] Lancement du conteneur backend...'

            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH/.env:/app/.env" \
              -v "$MOUNT_PATH/logs:/app/logs" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "$BACKEND_PORT:$BACKEND_PORT" \
              "$DOCKER_NAME" || {
                echo '[ERROR] Échec du démarrage du conteneur backend.' >&2
                exit 1
            }

            # Vérification du contenu de /app/prisma
            docker exec "$CONTAINER_NAME" ls -la /app/prisma
                            
            # Étape 8.7 - Vérification du conteneur
            echo '[INFO - Étape 8.7] Vérification que le conteneur est actif...'
            if docker ps --filter "name=$CONTAINER_NAME" --filter "status=running" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              echo '[SUCCESS] Le conteneur backend est actif et opérationnel.'
            else
              echo '[ERROR] Le conteneur backend n’est pas opérationnel.' >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            fi
        
              # Nettoyage du fichier temporaire
              echo '[INFO] Suppression du fichier temporaire...'
              rm -f /tmp/env_vars_backend.sh
        
              echo '[SUCCESS] Déploiement terminé avec succès.'

            # Étape 8.8 - Vérification et initialisation conditionnelle de la base de données
            echo '[INFO - Étape 8.8] Vérification de l’état de la base de données...'
            TABLE_COUNT=$(psql -h $DB_HOST -U $DB_USERNAME -d $DB_NAME -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';" | xargs)

            if [ "$TABLE_COUNT" -eq "0" ]; then
              echo '[INFO] La base de données est vide. Exécution du script baseline.sql...'
              psql -h $DB_HOST -U $DB_USERNAME -d $DB_NAME -f "$MOUNT_PATH/baseline.sql"
            else
              echo '[INFO] La base de données est déjà initialisée. Aucun script baseline requis.'
            fi

            # Étape 8.9 - Déploiement des migrations Prisma avec gestion des baselines
            echo '[INFO - Étape 8.9] Déploiement des migrations Prisma...'

            # Ajout d'une vérification pour appliquer une baseline si nécessaire
            docker exec "$CONTAINER_NAME" npx prisma migrate status || {
              echo '[INFO] La base de données nécessite un baselining...'
              docker exec "$CONTAINER_NAME" npx prisma migrate resolve --applied "20241108005223_init"
            }

            docker exec "$CONTAINER_NAME" npx prisma migrate deploy || {
              echo '[ERROR] Échec du déploiement des migrations Prisma.' >&2
              exit 1
            }

            # Ajout d'une temporisation pour éviter les problèmes d'accès
            sleep 10

            # Debug : Vérification du fichier avant migration
            docker exec "$CONTAINER_NAME" ls -la /app/prisma/schema.prisma || {
              echo "[ERROR] Le fichier schema.prisma est introuvable." >&2
              exit 1
            }

            # Exécution de la migration
            docker exec "$CONTAINER_NAME" npx prisma migrate deploy --schema /app/prisma/schema.prisma || {
              echo '[ERROR] Échec du déploiement des migrations Prisma.' >&2
              exit 1
            }
          EOF

      # Étape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # Étape 10 - Nettoyage des fichiers temporaires
      - name: Nettoyer les fichiers temporaires
        run: rm -f /tmp/git_id_rsa