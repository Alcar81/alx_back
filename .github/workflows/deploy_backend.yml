# \backend/.github/workflows/deploy_backend.yml
name: D√©ployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}     
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      DOMAIN: ${{ secrets.DOMAIN }}
      GIT_REPO_URL: ${{ secrets.GIT_REPO_URL }}
      REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}
      LOGS_DIR: backend/logs

    steps:
      # √âtape 0 - Configurer l'agent SSH global
      - name: 0 - Configurer l'agent SSH (globale)
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Cl√© SSH invalide." && exit 1)

      # √âtape 1 : Pr√©paration initiale
      - name: 1 - Pr√©paration initiale
        run: |
          echo "=== D√©but de la pr√©paration initiale ==="
          echo "Cr√©ation du r√©pertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "R√©pertoire de logs cr√©√© avec succ√®s."
          echo "=== Fin de la pr√©paration initiale ==="  
      
      # √âtape 1.1 - Afficher les variables g√©n√©r√©es et valider leur pr√©sence
      - name: 1.1 - Afficher les variables g√©n√©r√©es
        run: |
          echo "[INFO] Affichage des variables g√©n√©r√©es : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET DOMAIN )
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done
      
      # √âtape 2 - R√©cup√©rer le d√©p√¥t Git
      - name: 2 - R√©cup√©rer le d√©p√¥t
        uses: actions/checkout@v3
        

      # √âtape 2.1 - V√©rification apr√®s checkout
      - name: 2.1 - V√©rification apr√®s checkout
        run: |
          echo "[INFO] V√©rification apr√®s le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable √† la racine. V√©rifiez la structure du d√©p√¥t." && exit 1
          fi

      # √âtape 2.1.1 - Configurer l'agent SSH pour le clonage
      - name: 2.1.1 - Configurer l'agent SSH
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          echo "=== √âtape 2.1.1 : Configuration de l'agent SSH ==="
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "[ERROR] Cl√© SSH invalide." && exit 1)
          echo "[SUCCESS] Agent SSH configur√© avec succ√®s."      
          
      # √âtape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.1'

      # √âtape 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
      - name: 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
        run: |
          echo "[INFO - 3.1] Cr√©ation du r√©pertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          echo "[INFO - 3.2] Installation des d√©pendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi
          echo "[INFO - 3.3] Validation des vuln√©rabilit√©s..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique √©chou√©. √Ä v√©rifier manuellement."
          }
          echo "[INFO - 3.4] Validation de l'arbre des d√©pendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de d√©pendances invalide d√©tect√©. R√©g√©n√©ration en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de d√©pendances valide."
          fi
          echo "[SUCCESS - 3.5] D√©pendances pr√™tes pour le d√©ploiement."  

      # √âtape 4 - Copier le code backend sur le serveur
      - name: 4 - Copier le code backend sur le serveur
        run: |
          echo "üìÇ Cr√©ation d‚Äôun r√©pertoire temporaire avec le backend..."
          mkdir -p backend_sync
          rsync -av --exclude='.git' --exclude='node_modules' --exclude='logs' ./ backend_sync/

          echo "üöÄ Envoi du backend au serveur distant..."
          ssh -p $SSH_PORT -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no $SSH_USER@$SERVER_IP "mkdir -p $MOUNT_PATH"
          
          rsync -av --exclude='.git' --exclude='node_modules' --exclude='logs' --include='migrate_auto.sh' ./ backend_sync/
          
          echo "üßº Nettoyage du r√©pertoire temporaire local..."
          rm -rf backend_sync

          echo "‚úÖ Backend copi√© avec succ√®s vers $MOUNT_PATH sur le serveur."  
        
      # √âtape 6 - Configuration du conteneur PostgreSQL      
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          echo "=== √âtape 6 : Configuration du conteneur PostgreSQL ==="

          # Sous-√©tape 6.1 : Cr√©er un fichier temporaire contenant les variables n√©cessaires
          echo "[INFO - Sous-√©tape 6.1] Cr√©ation du fichier temporaire contenant les variables..."
          cat <<EOT > /tmp/env_vars.sh
          ENV=$ENV
          NETWORK=$NETWORK
          POSTGRES_VOLUME=$POSTGRES_VOLUME
          POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME
          DB_USERNAME=$DB_USERNAME
          DB_PASSWORD=$DB_PASSWORD
          DB_NAME=$DB_NAME
          DB_PORT_INT=$DB_PORT_INT
          DB_PORT_EXT=$DB_PORT_EXT
          EOT

          # V√©rification de la cr√©ation du fichier temporaire
          if [ ! -f /tmp/env_vars.sh ]; then
            echo "[ERROR] √âchec de la cr√©ation du fichier temporaire /tmp/env_vars.sh." >&2
            exit 1
          fi

          # Sous-√©tape 6.2 : Copier le fichier temporaire vers le serveur distant
          echo "[INFO - Sous-√©tape 6.2] Envoi du fichier temporaire contenant les variables au serveur distant..."
          scp -P "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no /tmp/env_vars.sh "$SSH_USER@$SERVER_IP:/tmp/env_vars.sh"

          # Sous-√©tape 6.3 : Connexion SSH et ex√©cution des commandes sur le serveur distant
          ssh -p "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" << 'EOF'
          set -e

          # Charger les variables depuis le fichier temporaire
          source /tmp/env_vars.sh

          # V√©rifier/cr√©er le r√©seau Docker
          if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
            docker network create "$NETWORK"
          fi

          # V√©rifier/cr√©er le volume Docker
          if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
            docker volume create "$POSTGRES_VOLUME"
          fi

          # Arr√™ter et supprimer le conteneur PostgreSQL existant
          if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
            docker stop "$POSTGRES_CONTAINER_NAME" || true
            docker rm "$POSTGRES_CONTAINER_NAME" || true
          fi

          # Lancer un nouveau conteneur PostgreSQL
          docker run -d --name "$POSTGRES_CONTAINER_NAME" \
            --network "$NETWORK" \
            -e POSTGRES_USER="$DB_USERNAME" \
            -e POSTGRES_PASSWORD="$DB_PASSWORD" \
            -e POSTGRES_DB="$DB_NAME" \
            -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
            -p "$DB_PORT_EXT:$DB_PORT_INT" \
            postgres:13

          # V√©rifier que PostgreSQL est pr√™t
          for i in {1..10}; do
            if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U "$DB_USERNAME" -d "$DB_NAME"; then
              echo "[INFO] PostgreSQL est pr√™t."
              break
            else
              echo "[INFO] En attente... (tentative $i/10)"
              sleep 5
            fi
          done

          # V√©rifier/cr√©er le r√¥le "postgres"
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='postgres';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          fi

          # V√©rifier/cr√©er la base de donn√©es
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USERNAME;"
          fi

          echo "[INFO] Configuration de PostgreSQL termin√©e avec succ√®s."
          EOF

          # Nettoyer le fichier temporaire local
          rm -f /tmp/env_vars.sh          

      # √âtape 7 - Cr√©ation de la base de donn√©es et des utilisateurs
      - name: 7 - Cr√©ation de la base de donn√©es et des utilisateurs
        run: |
          echo "=== √âtape 7 : Cr√©ation de la base de donn√©es et des utilisateurs ==="

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - √âtape 7] Cr√©ation des utilisateurs et de la base de donn√©es...'

            # Assurez-vous que le r√©pertoire des logs existe
            LOG_DIR=\$(dirname "$LOG_FILE")
            mkdir -p "\$LOG_DIR"
            echo '[INFO] R√©pertoire des logs v√©rifi√©/cr√©√© : \$LOG_DIR' | tee -a "$LOG_FILE"

            # V√©rification et cr√©ation du r√¥le si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] R√¥le cr√©√© : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # V√©rification et cr√©ation de la base de donn√©es si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de donn√©es cr√©√©e : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] √âtape 7 termin√©e avec succ√®s.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - D√©ployer le conteneur Backend (build + d√©marrage)
        run: |
          echo "=== √âtape 8.0 : D√©ploiement du backend ==="
      
          # 8.1 - Construction de DATABASE_URL
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT_INT}/${DB_NAME}"
          echo "[INFO - 8.1] DATABASE_URL construit : $DATABASE_URL"
      
          # 8.2 - Connexion SSH et d√©ploiement
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" \
          "ENV='$ENV' DATABASE_URL='$DATABASE_URL' JWT_SECRET='$JWT_SECRET' BACKEND_PORT='$BACKEND_PORT' MOUNT_PATH='$MOUNT_PATH' POSTGRES_CONTAINER_NAME='$POSTGRES_CONTAINER_NAME' DB_USERNAME='$DB_USERNAME' DB_NAME='$DB_NAME' CONTAINER_NAME='$CONTAINER_NAME' NETWORK='$NETWORK' DOCKER_NAME='$DOCKER_NAME' DB_PASSWORD='$DB_PASSWORD' REACT_APP_API_URL='$REACT_APP_API_URL' bash -s" << 'EOF'
      
            set -e
            echo "=== √âtape 8.2 : D√©ploiement sur le serveur ==="
      
            # 8.2.1 - V√©rification des variables d'environnement
            echo "[INFO - 8.2.1] V√©rification des variables..."
            REQUIRED_VARS=(ENV DATABASE_URL JWT_SECRET BACKEND_PORT MOUNT_PATH DB_NAME DB_USERNAME DB_PASSWORD CONTAINER_NAME NETWORK)
            for VAR in "${REQUIRED_VARS[@]}"; do
              VALUE=$(eval echo "\$$VAR")
              if [ -z "$VALUE" ]; then
                echo "[ERROR] ‚ùå La variable $VAR est manquante." >&2
                exit 1
              fi
              echo "[OK] $VAR=$VALUE"
            done
      
            # 8.2.2 - G√©n√©ration du fichier .env
            echo "[INFO - 8.2.2] Cr√©ation du fichier .env..."
            cat <<EOT > "$MOUNT_PATH/.env"
            DATABASE_URL=$DATABASE_URL
            NODE_ENV=$ENV
            APP_ENV=$ENV
            APP_NAME=alxmultimedia_backend
            JWT_SECRET=$JWT_SECRET
            SERVER_PORT=$BACKEND_PORT
            PORT=$BACKEND_PORT
            REACT_APP_API_URL=$REACT_APP_API_URL
            TRUST_PROXY=1
            LOG_LEVEL=info
            ENABLE_CACHE=false
          EOT
      
            # 8.2.3 - Nettoyage des logs
            echo "[INFO - 8.2.3] Nettoyage des anciens logs..."
            mkdir -p "$MOUNT_PATH/logs"
            rm -f "$MOUNT_PATH/logs/*" || echo "[WARNING] Rien √† supprimer."
            find "$MOUNT_PATH/logs/" -type f -name "*.log" -mtime +7 -exec rm -f {} \;
      
            # 8.3 - Suppression de l'ancien conteneur
            echo "[INFO - 8.3] Suppression de l'ancien conteneur..."
            if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
              docker stop "$CONTAINER_NAME" || true
              docker rm "$CONTAINER_NAME" || true
            fi
      
            # 8.4 - D√©marrage du nouveau conteneur vide
            echo "[INFO - 8.4] D√©marrage d‚Äôun conteneur temporaire..."
            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH:/app" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "127.0.0.1:$BACKEND_PORT:$BACKEND_PORT" \
              node:20 \
              tail -f /dev/null
      
            # 8.5 - Installation des d√©pendances
            echo "[INFO - 8.5] Installation des d√©pendances..."
            docker exec "$CONTAINER_NAME" npm install --omit=dev --loglevel=warn
            docker exec "$CONTAINER_NAME" npm install node-fetch@2 --loglevel=warn
            docker exec "$CONTAINER_NAME" apt-get update && apt-get install -y wget net-tools curl tzdata
            docker exec "$CONTAINER_NAME" ln -sf /usr/share/zoneinfo/America/Montreal /etc/localtime
            docker exec "$CONTAINER_NAME" dpkg-reconfigure -f noninteractive tzdata
      
            # 8.6 - G√©n√©ration Prisma et build
            echo "[INFO - 8.6] Prisma generate et npm build..."
            docker exec "$CONTAINER_NAME" npx prisma generate
            docker exec "$CONTAINER_NAME" npm run build || echo "[INFO] Aucun build requis"
      
            # 8.7 - Connexion DB (pr√©-migration)
            echo "[INFO - 8.7] Test de connexion DB..."
            docker exec "$CONTAINER_NAME" node /app/tests/testDbConnection.js
      
            # 8.8 - Application des migrations Prisma
            echo "[INFO - 8.8] Lancement des migrations..."
            docker exec "$CONTAINER_NAME" npx prisma migrate deploy
      
            # 8.9 - Backup post-migration
            echo "[INFO - 8.9] Backup de la base apr√®s migration..."
            BACKUP_DIR="$(dirname "$MOUNT_PATH")/backup_bd"
            mkdir -p "$BACKUP_DIR"
            BACKUP_FILE="$BACKUP_DIR/backup_after_migrate_$(date +%Y%m%d%H%M%S).sql"
            docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" -d "$DB_NAME" > "$BACKUP_FILE"
            sleep 30
      
            # 8.10 - Lancement du serveur backend
            echo "[INFO - 8.10] D√©marrage du backend..."
            docker exec -d "$CONTAINER_NAME" npm start
            
      
            echo "[INFO - 8.10.1] V√©rification du log de d√©marrage..."
            docker exec "$CONTAINER_NAME" grep "\[BOOT\]" logs/server.log || {
              echo "[ERROR] üö® Le serveur ne semble pas avoir d√©marr√© correctement."
              docker exec "$CONTAINER_NAME" tail -n 100 logs/server.log
              exit 1
            }
      
            # 8.11 - V√©rification port et endpoint
            echo "[INFO - 8.11] V√©rification port et endpoint /health..."
            for i in {1..120}; do
              if docker exec "$CONTAINER_NAME" netstat -tln | grep -q ":$BACKEND_PORT"; then
                echo "[OK] Port $BACKEND_PORT ouvert"
                break
              fi
              echo "[WAIT] Port pas encore actif ($i/120)..."
              sleep 1
            done
      
            # 8.12 - Tests post-d√©ploiement (testComplet.js)
            echo "[INFO - 8.12] Lancement des tests automatis√©s post-d√©ploiement..."
      
            if [ "$ENV" = "dev" ]; then
              echo "[INFO] Mode d√©veloppement - testComplet.js --debug"
              docker exec "$CONTAINER_NAME" node /app/tests/testComplet.js --debug
            else
              echo "[INFO] Mode production - testComplet.js"
              docker exec "$CONTAINER_NAME" node /app/tests/testComplet.js
            fi
      
            # 8.13 - Nettoyage final
            echo "[INFO - 8.13] Suppression des fichiers temporaires..."
            rm -f /tmp/git_id_rsa /tmp/env_vars.sh
      
            echo "[SUCCESS ‚úÖ] √âtape 8 termin√©e avec succ√®s."
      
          EOF
        
          

      # √âtape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # √âtape 10 - Nettoyage des fichiers temporaires
      - name: 10 - Nettoyage des fichiers temporaires
        run: rm -f /tmp/git_id_rsa /tmp/env_vars.sh || true        
