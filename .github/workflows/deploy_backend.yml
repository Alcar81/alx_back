name: Déployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:${{ secrets.DB_PASSWORD }}@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      # Étape 1 - Préparation des logs
      - name: Préparer les logs
        run: |
          mkdir -p backend/logs || (echo "Erreur : Impossible de créer le répertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "=== Déploiement Backend : $(date) ===" > $LOG_FILE   

      # Étape 1 - Afficher les variables générées
      - name: 1.1 - Afficher les variables générées
        run: |
          echo "Environnement : $ENV" | tee -a $LOG_FILE
          echo "Nom de la base de données : $DB_NAME" | tee -a $LOG_FILE
          echo "Hôte de la base de données : $DB_HOST" | tee -a $LOG_FILE

      # Étape 2 - Récupérer le dépôt Git
      - name: 2 - Récupérer le dépôt
        uses: actions/checkout@v3

      # Étape 2.5 - Configurer la version de Node.js
      - name: Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      # Étape 3 - Installer les dépendances et corriger les vulnérabilités
      - name: 3 - Installer les dépendances et corriger les vulnérabilités
        run: |
          mkdir -p backend/logs || (echo "Erreur : Impossible de créer le répertoire des logs." && exit 1)
          npm install --production | tee -a backend/logs/backend_deploy.log || exit 1
          npm audit fix | tee -a backend/logs/backend_deploy.log || exit 1

      # Étape 4 - Construire l'image Docker pour le backend
      - name: 4 - Construire l'image Docker
        run: |
          docker image prune -f || (echo "Erreur : Impossible de nettoyer les images Docker." && exit 1)
          docker build -t $DOCKER_NAME -f Dockerfile.backend . | tee -a backend/logs/backend_deploy.log
      
      # Étape 5 - Démarrer l'agent SSH et ajouter la clé
      - name: 5 - Démarrer l'agent SSH et ajouter la clé
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Clé SSH invalide." && exit 1)
        

      # Étape 6 - Démarrer le conteneur PostgreSQL
      - name: 6 - Démarrer le conteneur PostgreSQL
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            echo '[INFO - Étape 6] Configuration du conteneur PostgreSQL...' | tee -a $LOG_FILE
            
            # Vérification et création du réseau Docker
            if ! docker network ls --filter \"name=^$NETWORK\$\" --format '{{.Name}}' | grep -w $NETWORK; then
              echo '[INFO - Étape 6] Création du réseau Docker : $NETWORK' | tee -a $LOG_FILE
              docker network create $NETWORK
            else
              echo '[INFO - Étape 6] Réseau Docker déjà existant : $NETWORK' | tee -a $LOG_FILE
            fi

            # Vérification et création du volume Docker
            if ! docker volume ls --filter \"name=^$POSTGRES_VOLUME\$\" --format '{{.Name}}' | grep -w $POSTGRES_VOLUME; then
              echo '[INFO - Étape 6] Création du volume Docker : $POSTGRES_VOLUME' | tee -a $LOG_FILE
              docker volume create $POSTGRES_VOLUME
            else
              echo '[INFO - Étape 6] Volume Docker déjà existant : $POSTGRES_VOLUME' | tee -a $LOG_FILE
            fi

            # Arrêt et suppression de l'ancien conteneur PostgreSQL
            if docker ps -a --filter \"name=$POSTGRES_CONTAINER_NAME\" --format '{{.Names}}' | grep -w $POSTGRES_CONTAINER_NAME; then
              echo '[INFO - Étape 6] Arrêt et suppression de l’ancien conteneur : $POSTGRES_CONTAINER_NAME' | tee -a $LOG_FILE
              docker stop $POSTGRES_CONTAINER_NAME
              docker rm $POSTGRES_CONTAINER_NAME
            fi

            # Téléchargement de l'image PostgreSQL la plus récente
            echo '[INFO - Étape 6] Mise à jour de l’image PostgreSQL...' | tee -a $LOG_FILE
            docker pull postgres:13

            # Lancement d’un nouveau conteneur PostgreSQL
            echo '[INFO - Étape 6] Démarrage du nouveau conteneur PostgreSQL : $POSTGRES_CONTAINER_NAME' | tee -a $LOG_FILE
            docker run -d --name $POSTGRES_CONTAINER_NAME \
              --network $NETWORK \
              -e POSTGRES_USER=$DB_USERNAME \
              -e POSTGRES_PASSWORD=$DB_PASSWORD \
              -e POSTGRES_DB=$DB_NAME \
              -v $POSTGRES_VOLUME:/var/lib/postgresql/data \
              -p $DB_PORT_EXT:$DB_PORT_INT \
              postgres:13

            # Vérification de l’état du conteneur PostgreSQL
            echo '[INFO - Étape 6] Vérification de l’état du conteneur...' | tee -a $LOG_FILE
            docker ps --filter \"name=$POSTGRES_CONTAINER_NAME\" | tee -a $LOG_FILE

            # Pause pour s’assurer que PostgreSQL démarre correctement
            echo '[INFO - Étape 6] Attente de 10 secondes pour la disponibilité de PostgreSQL...' | tee -a $LOG_FILE
            sleep 10

            # Vérification finale de l'état de PostgreSQL
            if docker exec $POSTGRES_CONTAINER_NAME pg_isready -U $DB_USERNAME; then
              echo '[SUCCESS - Étape 6] PostgreSQL est opérationnel.' | tee -a $LOG_FILE
            else
              echo '[ERROR - Étape 6] PostgreSQL n’est pas prêt après le délai d’attente.' | tee -a $LOG_FILE
              exit 1
            fi
          " | tee -a $LOG_FILE


      # Étape 6.1 - Nettoyer les anciens backups
      - name: 6.1 - Nettoyer les anciens backups (Prod uniquement)
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            find /root -name 'prod_backup_*.sql' -type f -mtime +7 -exec rm -f {} \;
          " | tee -a backend/logs/backend_deploy.log

      # Étape 6.2 - Sauvegarder la base de données
      - name: 6.2 - Sauvegarder la base de données (Prod uniquement)
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            docker exec $POSTGRES_CONTAINER_NAME pg_dump -U $DB_USERNAME $DB_NAME > /root/prod_backup_$(date +%Y%m%d%H%M%S).sql
          " | tee -a backend/logs/backend_deploy.log

      # Étape 7 - Créer la base de données et l'utilisateur démo
      - name: 7 - Créer la base de données et l'utilisateur démo
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            # Supprimer la base de données si elle existe
            echo '[INFO - Étape 7] Suppression de la base de données si elle existe...' | tee -a $LOG_FILE
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -c \"DROP DATABASE IF EXISTS $DB_NAME;\" || (echo 'Erreur : Impossible de supprimer la base de données.' && exit 1)

            # Supprimer le rôle si nécessaire
            echo '[INFO - Étape 7] Suppression du rôle si nécessaire...' | tee -a $LOG_FILE
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -c \"DROP ROLE IF EXISTS $DB_USERNAME;\" || (echo 'Erreur : Impossible de supprimer le rôle.' && exit 1)

            # Créer le rôle
            echo '[INFO - Étape 7] Création du rôle...' | tee -a $LOG_FILE
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -c \"CREATE ROLE $DB_USERNAME WITH LOGIN PASSWORD '$DB_PASSWORD';\" || (echo 'Erreur : Impossible de créer le rôle.' && exit 1)

            # Créer la base de données
            echo '[INFO - Étape 7] Création de la base de données...' | tee -a $LOG_FILE
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -c \"CREATE DATABASE $DB_NAME WITH OWNER $DB_USERNAME;\" || (echo 'Erreur : Impossible de créer la base de données.' && exit 1)

            # Accorder des privilèges
            echo '[INFO - Étape 7] Attribution des privilèges...' | tee -a $LOG_FILE
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -c \"GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USERNAME;\" || (echo 'Erreur : Impossible d’attribuer les privilèges.' && exit 1)

            echo '[SUCCESS - Étape 7] Base de données et utilisateur créés avec succès.' | tee -a $LOG_FILE
          " | tee -a $LOG_FILE

      # Étape 8 - Déployer le conteneur Backend 
      - name: 8 - Déployer le conteneur Backend
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
          echo '[INFO] Préparation du backend...' | tee -a $LOG_FILE

          # Valider les variables
          echo '[INFO] Validation des variables d'environnement :'
          echo "DATABASE_URL=postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
          echo "NODE_ENV=$ENV"
          echo "JWT_SECRET=$JWT_SECRET"
          echo "NETWORK=$NETWORK"
          echo "CONTAINER_NAME=$CONTAINER_NAME"
          echo "DOCKER_NAME=$DOCKER_NAME"
          echo "MOUNT_PATH=$MOUNT_PATH"
          echo "BACKEND_PORT=$BACKEND_PORT"

          # Vérification des logs
          echo '[INFO] Création du répertoire backend/logs si inexistant...' | tee -a $LOG_FILE
          mkdir -p backend/logs || (echo '[ERROR] Impossible de créer le répertoire backend/logs' && exit 1)

          # Arrêter et supprimer l'ancien conteneur
          docker ps -a --filter \"name=$CONTAINER_NAME\" --format '{{.Names}}' | grep -w $CONTAINER_NAME && docker stop $CONTAINER_NAME || true
          docker ps -a --filter \"name=$CONTAINER_NAME\" --format '{{.Names}}' | grep -w $CONTAINER_NAME && docker rm $CONTAINER_NAME || true

          # Déployer le nouveau conteneur Backend
          docker run -d --name $CONTAINER_NAME \
            --network $NETWORK \
            -e DATABASE_URL='$DATABASE_URL' \
            -e NODE_ENV='$ENV' \
            -e JWT_SECRET='$JWT_SECRET' \
            -v $MOUNT_PATH:/app \
            -w /app \
            -p $BACKEND_PORT:$BACKEND_PORT
            $DOCKER_NAME || (echo '[ERROR] Échec du démarrage du conteneur backend.' && exit 1)

            # Vérification de l'état du conteneur Backend
            echo '[INFO] Vérification état du conteneur Backend...' | tee -a $LOG_FILE
            docker ps --filter \"name=$CONTAINER_NAME\" | tee -a $LOG_FILE

            # Attente pour s’assurer que le backend démarre correctement
            echo '[INFO] Attente de 10 secondes pour le démarrage du backend...' | tee -a $LOG_FILE
            sleep 10

            # Tester l'endpoint /health
            echo '[INFO] Test endpoint /health...' | tee -a $LOG_FILE
            if curl -s http://localhost:$BACKEND_PORT/health | grep 'OK'; then
              echo '[SUCCESS] Le backend est opérationnel.' | tee -a $LOG_FILE
            else
              echo '[ERROR] Le backend ne répond pas correctement.' | tee -a $LOG_FILE
              exit 1
            fi
          " | tee -a $LOG_FILE

      # Étape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # Étape 10 - Nettoyage des fichiers temporaires
      - name: Nettoyer les fichiers temporaires
        run: rm -f /tmp/git_id_rsa