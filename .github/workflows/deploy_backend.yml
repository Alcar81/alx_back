name: Déployer Backend 

on:
  push:
    branches:      
      - dev
      - master
      # Ajoutez ici de nouvelles branches pour de nouveaux environnements (par exemple test)

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}
    # NOTE : L'environnement est automatiquement défini en fonction de la branche.
    # - 'master' correspond à 'prod'
    # - Toute autre branche correspond à 'dev' (ou ajustez si nécessaire).
    # - Pour ajouter un nouvel environnement :
    #   1. Ajoutez une branche correspondante ci-dessus (par exemple staging).
    #   2. Mettez à jour les secrets GitHub correspondants pour ce nouvel environnement (par ex. ENV, DB_POST, etc.).

    env:
      ENV: ${{ vars.ENV }}
      DB_PORT_INT: ${{ secrets.DB_PORT_INT }}
      DB_PORT_EXT: ${{ secrets.DB_PORT_EXT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://${{ vars.USR_DB }}_${{ vars.ENV }}:${{ secrets.DB_PASSWORD }}@${{ vars.DB_POST }}_${{ vars.ENV }}:${{ secrets.DB_PORT_INT }}/${{ vars.DB_POST }}_${{ vars.ENV }}"
      BACKEND_PORT: ${{ secrets.BACKEND_PORT }}

    steps:
      # Étape 1 - Afficher les variables générées
      - name: 1 - Afficher les variables générées
        run: |
          echo "Environnement : $ENV"
          echo "Nom de la base de données : $DB_NAME"
          echo "Hôte de la base de données : $DB_HOST"
          echo "Nom du conteneur PostgreSQL : $POSTGRES_CONTAINER_NAME"
          echo "URL de connexion à la base : $DATABASE_URL"

      # Étape 2 - Récupérer le dépôt Git
      - name: 2 - Récupérer le dépôt
        uses: actions/checkout@v3

      # Étape 2.5 - Configurer la version de Node.js
      - name: Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      # Étape 3 - Install dependencies
      - name: 3 - Install dependencies
        run: npm install

      # Étape 4 - Construire l'image Docker pour le backend
      - name: 4 - Construire l'image Docker
        env:
          DOCKER_NAME: "back_node:latest"
        run: docker build -t $DOCKER_NAME -f Dockerfile.backend .      

      # Étape 5 - Démarrer l'agent SSH et ajouter la clé
      - name: 5 - Démarrer l'agent SSH et ajouter la clé
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa

      # Étape 6 - Démarrer le conteneur PostgreSQL
      - name: 6 - Démarrer le conteneur PostgreSQL
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/$ENV/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            docker network create $NETWORK || true &&
            docker volume create $POSTGRES_VOLUME || true &&
            docker ps -a --filter \"name=$POSTGRES_CONTAINER_NAME\" --format '{{.Names}}' | grep -w $POSTGRES_CONTAINER_NAME && docker stop $POSTGRES_CONTAINER_NAME || true &&
            docker ps -a --filter \"name=$POSTGRES_CONTAINER_NAME\" --format '{{.Names}}' | grep -w $POSTGRES_CONTAINER_NAME && docker rm $POSTGRES_CONTAINER_NAME || true &&
            docker pull postgres:13 &&
            docker run -d --name $POSTGRES_CONTAINER_NAME \
              --network $NETWORK \
              -e POSTGRES_USER=$DB_USERNAME \
              -e POSTGRES_PASSWORD=$DB_PASSWORD \
              -e POSTGRES_DB=$DB_NAME \
              -v $POSTGRES_VOLUME:/var/lib/postgresql/data \
              -p $DB_PORT_EXT:$DB_PORT_INT \
              postgres:13
          "

      # Étape 6.1 - Nettoyer les anciens backups
      - name: 6.1 - Cleanup old backups (Prod Only)        
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/prod/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            find /root -name 'prod_backup_*.sql' -type f -mtime +7 -exec rm -f {} \;
          "

      # Étape 6.2 - Sauvegarder la base de données
      - name: 6.2 - Backup PostgreSQL Database (Prod Only)
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/prod/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            docker exec $POSTGRES_CONTAINER_NAME pg_dump -U $DB_USERNAME $DB_NAME > /root/prod_backup_$(date +%Y%m%d%H%M%S).sql
          "

      # Étape 7 - Créer la base de données et l'utilisateur démo
      - name: 7 - Créer la base de données et l'utilisateur démo
        run: |
          # Affichage des informations de diagnostic
          echo "Environnement : $ENV"
          echo "Nom de la base de données : $DB_NAME"
          echo "Hôte de la base de données : $DB_HOST"
          echo "Nom du conteneur PostgreSQL : $POSTGRES_CONTAINER_NAME"
          echo "URL de connexion à la base : $DATABASE_URL"
          echo "Nom utilisateur : $DB_USERNAME"
          echo "Mot de passe de la base : $DB_PASSWORD"

          # Vérification de l'état du conteneur PostgreSQL avant de tenter la connexion
          echo "Vérification de l'état du conteneur PostgreSQL..."
          docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME"

          # Ajout d'une pause pour attendre que le conteneur PostgreSQL soit prêt
          echo "Attente de 10 secondes pour vérifier que le conteneur est bien prêt..."
          sleep 10

          # Connexion SSH et exécution des commandes pour créer la base et les rôles
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            # Création et vérification des bases de données et rôles
            echo 'Connexion réussie'

            echo 'Création des rôles et bases de données...'
            echo \"DROP DATABASE IF EXISTS $DB_NAME WITH OWNER $DB_USERNAME;\" > init_database.sql &&
            echo 'Vérification de la suppression de la base de données' &&
            echo \"CREATE DATABASE $DB_NAME WITH OWNER $DB_USERNAME;\" >> init_database.sql &&
            echo 'Création de la base de données' &&

            echo \"DROP ROLE IF EXISTS postgres;\" >> init_database.sql &&
            echo 'Vérification de la suppression du rôle postgres' &&
            echo \"DROP ROLE IF EXISTS $DB_USERNAME;\" >> init_database.sql &&
            echo 'Vérification de la suppression du rôle $DB_USERNAME' &&

            echo \"CREATE ROLE $DB_USERNAME WITH LOGIN PASSWORD '$DB_PASSWORD';\" >> init_database.sql &&
            echo 'Création du rôle $DB_USERNAME avec mot de passe' &&

            echo \"GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USERNAME;\" >> init_database.sql &&
            echo 'Attribution des privilèges' &&

            # Copie du fichier de commandes SQL dans le conteneur PostgreSQL
            docker cp init_database.sql $POSTGRES_CONTAINER_NAME:/tmp/init_database.sql &&

            # Exécution des commandes SQL dans PostgreSQL
            docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -f /tmp/init_database.sql &&

            # Nettoyage
            rm init_database.sql &&
            docker exec $POSTGRES_CONTAINER_NAME rm /tmp/init_database.sql

            echo 'Base de données et utilisateur créés avec succès.'

            # Si c'est l'environnement de production, restaurer la base de données depuis le backup
            if [ "$ENV" == "prod" ]; then
              echo 'Restauration de la base de données à partir du fichier de backup...'
              docker exec -i $POSTGRES_CONTAINER_NAME psql -U postgres -d $DB_NAME < /root/prod_backup_latest.sql
              echo 'Restauration terminée.'
            fi
          "


      # Étape 8 - Déployer le conteneur Backend
      - name: 8 - Déployer le conteneur Backend
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/$ENV/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
            docker ps -a --filter \"name=$CONTAINER_NAME\" --format '{{.Names}}' | grep -w $CONTAINER_NAME && docker stop $CONTAINER_NAME || true &&
            docker ps -a --filter \"name=$CONTAINER_NAME\" --format '{{.Names}}' | grep -w $CONTAINER_NAME && docker rm $CONTAINER_NAME || true &&
            docker run -d --name $CONTAINER_NAME \
              --network $NETWORK \
              -e DATABASE_URL=\"$DATABASE_URL\" \
              -e NODE_ENV=$ENV \
              -e JWT_SECRET=$JWT_SECRET \
              -v $MOUNT_PATH:/app \
              -w /app \
              -p $BACKEND_PORT:7000 \
              back_node:latest
          "

      # Étape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}
