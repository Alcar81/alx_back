# \backend/.github/workflows/deploy_backend.yml
name: D√©ployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}     
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      DOMAIN: ${{ secrets.DOMAIN }}
      GIT_REPO_URL: ${{ secrets.GIT_REPO_URL }}
      REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}
      LOGS_DIR: backend/logs

    steps:
      # √âtape 0 - Configurer l'agent SSH global
      - name: 0 - Configurer l'agent SSH (globale)
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Cl√© SSH invalide." && exit 1)

      # √âtape 1 : Pr√©paration initiale
      - name: 1 - Pr√©paration initiale
        run: |
          echo "=== D√©but de la pr√©paration initiale ==="
          echo "Cr√©ation du r√©pertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "R√©pertoire de logs cr√©√© avec succ√®s."
          echo "=== Fin de la pr√©paration initiale ==="  
      
      # √âtape 1.1 - Afficher les variables g√©n√©r√©es et valider leur pr√©sence
      - name: 1.1 - Afficher les variables g√©n√©r√©es
        run: |
          echo "[INFO] Affichage des variables g√©n√©r√©es : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET DOMAIN )
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done
      
      # √âtape 2 - R√©cup√©rer le d√©p√¥t Git
      - name: 2 - R√©cup√©rer le d√©p√¥t
        uses: actions/checkout@v3
        

      # √âtape 2.1 - V√©rification apr√®s checkout
      - name: 2.1 - V√©rification apr√®s checkout
        run: |
          echo "[INFO] V√©rification apr√®s le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable √† la racine. V√©rifiez la structure du d√©p√¥t." && exit 1
          fi

      # √âtape 2.1.1 - Configurer l'agent SSH pour le clonage
      - name: 2.1.1 - Configurer l'agent SSH
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          echo "=== √âtape 2.1.1 : Configuration de l'agent SSH ==="
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "[ERROR] Cl√© SSH invalide." && exit 1)
          echo "[SUCCESS] Agent SSH configur√© avec succ√®s."      
          
      # √âtape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.1'

      # √âtape 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
      - name: 3 - Installer les d√©pendances et valider l'arbre de d√©pendances
        run: |
          echo "[INFO - 3.1] Cr√©ation du r√©pertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de cr√©er le r√©pertoire des logs." && exit 1)
          echo "[INFO - 3.2] Installation des d√©pendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi
          echo "[INFO - 3.3] Validation des vuln√©rabilit√©s..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique √©chou√©. √Ä v√©rifier manuellement."
          }
          echo "[INFO - 3.4] Validation de l'arbre des d√©pendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de d√©pendances invalide d√©tect√©. R√©g√©n√©ration en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de d√©pendances valide."
          fi
          echo "[SUCCESS - 3.5] D√©pendances pr√™tes pour le d√©ploiement."  

      # √âtape 4 - Copier le code backend sur le serveur
      - name: 4 - Copier le code backend sur le serveur
        run: |
          echo "üìÇ Cr√©ation d‚Äôun r√©pertoire temporaire avec le backend..."
          mkdir -p backend_sync
          rsync -av --exclude='.git' --exclude='node_modules' --exclude='logs' ./ backend_sync/

          echo "üöÄ Envoi du backend au serveur distant..."
          ssh -p $SSH_PORT -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no $SSH_USER@$SERVER_IP "mkdir -p $MOUNT_PATH"
          
          rsync -avz backend_sync/ $SSH_USER@$SERVER_IP:$MOUNT_PATH/ -e "ssh -p $SSH_PORT -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
          
          echo "üßº Nettoyage du r√©pertoire temporaire local..."
          rm -rf backend_sync

          echo "‚úÖ Backend copi√© avec succ√®s vers $MOUNT_PATH sur le serveur."  
        
      # √âtape 6 - Configuration du conteneur PostgreSQL      
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          echo "=== √âtape 6 : Configuration du conteneur PostgreSQL ==="

          # Sous-√©tape 6.1 : Cr√©er un fichier temporaire contenant les variables n√©cessaires
          echo "[INFO - Sous-√©tape 6.1] Cr√©ation du fichier temporaire contenant les variables..."
          cat <<EOT > /tmp/env_vars.sh
          ENV=$ENV
          NETWORK=$NETWORK
          POSTGRES_VOLUME=$POSTGRES_VOLUME
          POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME
          DB_USERNAME=$DB_USERNAME
          DB_PASSWORD=$DB_PASSWORD
          DB_NAME=$DB_NAME
          DB_PORT_INT=$DB_PORT_INT
          DB_PORT_EXT=$DB_PORT_EXT
          EOT

          # V√©rification de la cr√©ation du fichier temporaire
          if [ ! -f /tmp/env_vars.sh ]; then
            echo "[ERROR] √âchec de la cr√©ation du fichier temporaire /tmp/env_vars.sh." >&2
            exit 1
          fi

          # Sous-√©tape 6.2 : Copier le fichier temporaire vers le serveur distant
          echo "[INFO - Sous-√©tape 6.2] Envoi du fichier temporaire contenant les variables au serveur distant..."
          scp -P "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no /tmp/env_vars.sh "$SSH_USER@$SERVER_IP:/tmp/env_vars.sh"

          # Sous-√©tape 6.3 : Connexion SSH et ex√©cution des commandes sur le serveur distant
          ssh -p "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" << 'EOF'
          set -e

          # Charger les variables depuis le fichier temporaire
          source /tmp/env_vars.sh

          # V√©rifier/cr√©er le r√©seau Docker
          if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
            docker network create "$NETWORK"
          fi

          # V√©rifier/cr√©er le volume Docker
          if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
            docker volume create "$POSTGRES_VOLUME"
          fi

          # Arr√™ter et supprimer le conteneur PostgreSQL existant
          if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
            docker stop "$POSTGRES_CONTAINER_NAME" || true
            docker rm "$POSTGRES_CONTAINER_NAME" || true
          fi

          # Lancer un nouveau conteneur PostgreSQL
          docker run -d --name "$POSTGRES_CONTAINER_NAME" \
            --network "$NETWORK" \
            -e POSTGRES_USER="$DB_USERNAME" \
            -e POSTGRES_PASSWORD="$DB_PASSWORD" \
            -e POSTGRES_DB="$DB_NAME" \
            -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
            -p "$DB_PORT_EXT:$DB_PORT_INT" \
            postgres:13

          # V√©rifier que PostgreSQL est pr√™t
          for i in {1..10}; do
            if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U "$DB_USERNAME" -d "$DB_NAME"; then
              echo "[INFO] PostgreSQL est pr√™t."
              break
            else
              echo "[INFO] En attente... (tentative $i/10)"
              sleep 5
            fi
          done

          # V√©rifier/cr√©er le r√¥le "postgres"
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='postgres';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          fi

          # V√©rifier/cr√©er la base de donn√©es
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME';" | grep -q 1; then
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USERNAME;"
          fi

          echo "[INFO] Configuration de PostgreSQL termin√©e avec succ√®s."
          EOF

          # Nettoyer le fichier temporaire local
          rm -f /tmp/env_vars.sh          

      # √âtape 7 - Cr√©ation de la base de donn√©es et des utilisateurs
      - name: 7 - Cr√©ation de la base de donn√©es et des utilisateurs
        run: |
          echo "=== √âtape 7 : Cr√©ation de la base de donn√©es et des utilisateurs ==="

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - √âtape 7] Cr√©ation des utilisateurs et de la base de donn√©es...'

            # Assurez-vous que le r√©pertoire des logs existe
            LOG_DIR=\$(dirname "$LOG_FILE")
            mkdir -p "\$LOG_DIR"
            echo '[INFO] R√©pertoire des logs v√©rifi√©/cr√©√© : \$LOG_DIR' | tee -a "$LOG_FILE"

            # V√©rification et cr√©ation du r√¥le si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] R√¥le cr√©√© : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # V√©rification et cr√©ation de la base de donn√©es si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de donn√©es cr√©√©e : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] √âtape 7 termin√©e avec succ√®s.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - D√©ployer le conteneur Backend
        run: |
          echo "=== √âtape 8.0.0 : D√©ploiement du backend ==="

          # 8.0.1 - Construire DATABASE_URL localement
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT_INT}/${DB_NAME}"
          echo "[INFO - 8.0.1] DATABASE_URL construit : $DATABASE_URL"

          # 8.0.2 - Connexion SSH et d√©ploiement
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" \
          "ENV='$ENV' DATABASE_URL='$DATABASE_URL' JWT_SECRET='$JWT_SECRET' BACKEND_PORT='$BACKEND_PORT' MOUNT_PATH='$MOUNT_PATH' POSTGRES_CONTAINER_NAME='$POSTGRES_CONTAINER_NAME' DB_USERNAME='$DB_USERNAME' DB_NAME='$DB_NAME' CONTAINER_NAME='$CONTAINER_NAME' NETWORK='$NETWORK' DOCKER_NAME='$DOCKER_NAME' DB_PASSWORD='$DB_PASSWORD' REACT_APP_API_URL='$REACT_APP_API_URL' bash -s" << 'EOF'
            set -e

            echo "=== D√©ploiement du backend sur le serveur ==="

            # 8.1 - V√©rification des variables
            echo "[INFO - 8.1] V√©rification des variables n√©cessaires..."
            REQUIRED_VARS=(ENV DATABASE_URL JWT_SECRET BACKEND_PORT MOUNT_PATH)
            for VAR in "${REQUIRED_VARS[@]}"; do
              VALUE=$(eval echo "\$$VAR")
              if [ -z "$VALUE" ]; then
                echo "[ERROR] La variable $VAR est manquante." >&2
                exit 1
              fi
              echo "[INFO] $VAR=$VALUE"
            done
         
            # 8.2 - Cr√©ation du fichier .env
            echo "[INFO - 8.2] Cr√©ation et v√©rification du fichier .env..."
            cat <<EOT > "$MOUNT_PATH/.env"
            DATABASE_URL=$DATABASE_URL
            NODE_ENV=$ENV
            APP_ENV=$ENV
            APP_NAME=alxmultimedia_backend
            JWT_SECRET=$JWT_SECRET
            SERVER_PORT=$BACKEND_PORT
            PORT=$BACKEND_PORT
            REACT_APP_API_URL=$REACT_APP_API_URL
            TRUST_PROXY=1
            LOG_LEVEL=info
            ENABLE_CACHE=false
          EOT

            echo "[INFO - 8.2] Contenu g√©n√©r√© de $MOUNT_PATH/.env :"
            cat "$MOUNT_PATH/.env"

            echo "[INFO - 8.2] V√©rification des variables d'environnement pass√©es :"
            echo "ENV=$ENV"
            echo "BACKEND_PORT=$BACKEND_PORT"
            echo "DATABASE_URL=$DATABASE_URL"
            echo "JWT_SECRET=$JWT_SECRET"
            echo "REACT_APP_API_URL=$REACT_APP_API_URL"

            # 8.3 - Pr√©paration du conteneur backend
            echo "[INFO - 8.3.1] Nettoyage des logs existants..."
            mkdir -p "$MOUNT_PATH/logs"
            rm -f "$MOUNT_PATH/logs/*" || echo "[WARNING] Aucune log √† nettoyer ou suppression √©chou√©e."

            # üî• Suppression de l'ancien fichier npm_start_output.log (inutile maintenant)
            rm -f "$MOUNT_PATH/logs/npm_start_output.log" || echo "[INFO] Aucun npm_start_output.log √† supprimer"

            # 8.3.1.1 - Suppression des logs plus vieux que 7 jours
            echo "[INFO - 8.3.1.1] Suppression des logs plus vieux que 7 jours..."
            find "$MOUNT_PATH/logs/" -type f -name "*.log" -mtime +7 -exec rm -f {} \; || echo "[WARNING] Aucune log ancienne √† supprimer."


            # √âtape 8.3.2 - Suppression de l‚Äôancien conteneur
            echo "[INFO - 8.3.2] Nettoyage de l‚Äôancien conteneur backend..."
            if docker ps -a --filter "name=$CONTAINER_NAME" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              docker stop "$CONTAINER_NAME" || echo "[WARNING] √âchec de l'arr√™t du conteneur."
              docker rm "$CONTAINER_NAME" || echo "[WARNING] √âchec de la suppression du conteneur."
            fi

            echo "[INFO - 8.3.3] Lancement du nouveau conteneur backend..." 
            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH:/app" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "127.0.0.1:$BACKEND_PORT:$BACKEND_PORT" \
              node:20 \
              tail -f /dev/null

            # üì¶ Installation des d√©pendances Node.js dans le conteneur
            echo "[INFO - 8.3.3.1] Installation des d√©pendances npm dans le conteneur..."
            docker exec "$CONTAINER_NAME" npm install --omit=dev --loglevel=warn || {
              echo "[ERROR] npm install a √©chou√©." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            # üì¶ Installation explicite de node-fetch@2 (pour compatibilit√© avec require)
            echo "[INFO - 8.3.3.1.1] Installation sp√©cifique de node-fetch@2 dans le conteneur..."
            docker exec "$CONTAINER_NAME" npm install node-fetch@2 --loglevel=warn || {
              echo "[ERROR] L'installation de node-fetch@2 a √©chou√©." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            # üì¶ Installation de wget, net-tools, et curl pour les v√©rifications r√©seau
            echo "[INFO - 8.3.3.1.2] Installation de wget, net-tools et curl..."
            docker exec "$CONTAINER_NAME" apt-get update && \
            docker exec "$CONTAINER_NAME" apt-get install -y wget net-tools curl || {
              echo "[ERROR] L'installation de wget/net-tools/curl a √©chou√©." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            # (optionnel mais utile) ‚úÖ Installation de tzdata pour g√©rer les fuseaux horaires si besoin
            echo "[INFO - 8.3.3.1.3] Installation de tzdata (optionnelle)..."
            docker exec "$CONTAINER_NAME" apt-get install -y tzdata || {
              echo "[WARNING] √âchec de l'installation de tzdata (peut √™tre ignor√© si non critique)." >&2
            }
            
            # üåê Configuration de la zone horaire √† America/Toronto
            echo "[INFO - 8.3.3.1.4] Configuration de la zone horaire √† America/Montreal..."
            docker exec "$CONTAINER_NAME" ln -sf /usr/share/zoneinfo/America/Montreal /etc/localtime
            docker exec "$CONTAINER_NAME" dpkg-reconfigure -f noninteractive tzdata

            # üìù Installation de nano (√©diteur de texte)
            echo "[INFO - 8.3.3.1.5] Installation de nano..."
            docker exec "$CONTAINER_NAME" apt-get install -y nano || {
              echo "[WARNING] √âchec de l'installation de nano." >&2
            }

            # üì¶ (optionnel mais recommand√©) G√©n√©rer le client Prisma
            echo "[INFO - 8.3.3.1.6] G√©n√©ration du client Prisma..."
            docker exec "$CONTAINER_NAME" npx prisma generate || {
              echo "[ERROR] La g√©n√©ration de Prisma a √©chou√©." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            # üõ†Ô∏è Build du projet (si applicable, ex: TypeScript ou bundler)
            echo "[INFO - 8.3.3.1.7] Construction du projet (npm run build)..."
            docker exec "$CONTAINER_NAME" npm run build || {
              echo "[ERROR] Le build du projet a √©chou√©." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            # üöÄ Lancement de l'application manuellement
            echo "[INFO - 8.3.3.2] D√©marrage manuel du serveur backend..."
            docker exec -d "$CONTAINER_NAME" npm start || {
              echo "[ERROR] √âchec du d√©marrage du serveur." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            }

            echo "[DEBUG] üîç Logs du conteneur backend (30 derni√®res lignes) :"
            docker logs "$CONTAINER_NAME" | tail -n 30

            # üîç V√©rifications suppl√©mentaires apr√®s le lancement du conteneur
            echo "[DEBUG] üìÇ Liste des fichiers dans /app dans le conteneur :"
            docker exec "$CONTAINER_NAME" ls -la /app || echo "[WARNING] Impossible de lister /app"

            echo "[DEBUG] üìÑ D√©but du fichier server.js (20 premi√®res lignes) :"
            docker exec "$CONTAINER_NAME" head -n 20 /app/server.js || echo "[WARNING] Fichier server.js introuvable"

            echo "[DEBUG] üîç V√©rification pr√©sence de 'helmet' dans server.js..."
            if docker exec "$CONTAINER_NAME" grep -q "helmet" /app/server.js; then
              echo "[OK ‚úÖ] 'helmet' est bien pr√©sent dans server.js"
            else
              echo "[‚ö†Ô∏è ATTENTION] 'helmet' n'a pas √©t√© trouv√© dans server.js !"
            fi

            echo "[DEBUG] üîê Aper√ßu du fichier .env dans le conteneur (10 premi√®res lignes) :"
            docker exec "$CONTAINER_NAME" head -n 10 /app/.env || echo "[WARNING] Fichier .env introuvable"

            echo "[SUCCESS] D√©ploiement backend termin√© avec succ√®s √† $(date '+%Y-%m-%d %H:%M:%S')" > "$MOUNT_PATH/logs/deployment_success.log"

            # √âtape 8.3.4 - V√©rification que le conteneur est actif.
            echo "[INFO - 8.3.4] V√©rification du conteneur backend..."
            if ! docker ps --filter "name=$CONTAINER_NAME" --filter "status=running" | grep -w "$CONTAINER_NAME"; then
              echo "[ERROR] Le conteneur backend n'est pas op√©rationnel." >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            fi
            echo "[SUCCESS] Le conteneur backend est actif."

            echo "[DEBUG] Contenu du server.js apr√®s lancement du conteneur :"
            docker exec "$CONTAINER_NAME" head -n 20 /app/server.js

            # üïí Attente que le serveur soit pr√™t sur le port 7001
            echo "[INFO - 8.3.5] Attente que le port $BACKEND_PORT soit ouvert dans le conteneur..."
            PORT_OK=0
            for i in {1..60}; do
              if docker exec "$CONTAINER_NAME" netstat -tln | grep -q ":$BACKEND_PORT"; then
                echo "[SUCCESS] ‚úÖ Le serveur √©coute bien sur le port $BACKEND_PORT"
                PORT_OK=1
                break
              else
                echo "[WAITING] üïì Port non ouvert... tentative $i/60"
                sleep 1
              fi
            done

            if [ "$PORT_OK" -eq 0 ]; then
              echo "[WARNING] ‚ùå Le port $BACKEND_PORT n‚Äôest pas ouvert apr√®s 60 secondes."
              echo "[INFO] Le d√©ploiement continue pour permettre l'inspection des logs et de Prisma."
            fi

            echo "[INFO - 8.3.5.1] Affichage des logs du conteneur (apr√®s tentative)..."
            docker logs "$CONTAINER_NAME" | tail -n 40

            # üåê V√©rification bloquante de l'endpoint /health
            if [ "$PORT_OK" -eq 1 ]; then
              echo "[INFO - 8.3.6] V√©rification de l'endpoint /health..."
              if docker exec "$CONTAINER_NAME" wget --spider -q http://localhost:$BACKEND_PORT/health; then
                echo "[SUCCESS] ‚úÖ Endpoint /health disponible"
              else
                echo "[WARNING] ‚ö†Ô∏è Endpoint /health inaccessible malgr√© le port ouvert."
              fi
            else
              echo "[INFO - 8.3.6] üîÅ Saut de la v√©rification /health (port ferm√©)."
            fi


            # (Optionnel) üîê V√©rification d'une route prot√©g√©e ou critique
            echo "[INFO - 8.3.7] V√©rification d'une route API cl√© (/api/me)..."
            if docker exec "$CONTAINER_NAME" wget --spider -q http://localhost:7001/api/me; then
              echo "[SUCCESS] ‚úÖ La route /api/me est disponible"
            else
              echo "[WARNING] ‚ö†Ô∏è La route /api/me est inaccessible (peut √™tre normal si pas encore connect√©e)"
            fi

            # 8.3.8 - V√©rification post-d√©ploiement de l'API
            echo "[INFO - 8.3.8] Test post-d√©ploiement de Prisma, /health et /api/register..."

            echo "[TEST] üì¶ Lancement de testPrisma.js..."
            if docker exec "$CONTAINER_NAME" node /app/tests/testPrisma.js; then
              echo "[SUCCESS] ‚úÖ testPrisma.js a r√©ussi la connexion √† la base de donn√©es"
            else
              echo "[ERROR] ‚ùå testPrisma.js a √©chou√©. V√©rifiez la connexion Prisma." >&2
              exit 1
            fi

            echo "[TEST] üåê V√©rification de /health via curl..."
            if docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "%{http_code}" http://localhost:$BACKEND_PORT/health | grep -q "200"; then
              echo "[SUCCESS] ‚úÖ L'endpoint /health r√©pond correctement"
            else
              echo "[ERROR] ‚ùå /health ne r√©pond pas comme attendu." >&2
              exit 1
            fi

            echo "[TEST] üë§ V√©rification de /api/register avec un appel fictif..."
            RESPONSE=$(docker exec "$CONTAINER_NAME" curl -s -X POST http://localhost:$BACKEND_PORT/api/register \
              -H "Content-Type: application/json" \
              -d '{"firstName":"Test","lastName":"Bot","email":"fakebot@example.com","password":"Fake1234!"}')

            if echo "$RESPONSE" | grep -q "email d√©j√† utilis√©\|created\|erreur attendue"; then
              echo "[SUCCESS] ‚úÖ /api/register r√©pond bien √† une requ√™te de test"
            else
              echo "[WARNING] ‚ö†Ô∏è R√©ponse inattendue de /api/register :"
              echo "$RESPONSE"
            fi

            # 8.3.9 - Nettoyage de l'utilisateur de test, quelle que soit l'environnement
            echo "[INFO - 8.3.9] Suppression de fakebot@example.com (si pr√©sent) dans la base de donn√©es..."

            # 8.3.9.1 - Cr√©er un fichier temporaire contenant le script Node.js
            echo "[INFO - 8.3.9.1] Cr√©er un fichier temporaire contenant le script Node.js..."
            TEMP_SCRIPT="/tmp/clean_test_user.js"
              cat <<"EOT" > "$TEMP_SCRIPT"
            const { PrismaClient } = require("@prisma/client");
            const prisma = new PrismaClient();
            async function clean() {
              try {
                // Ensure the 'user' model exists in your Prisma schema
                const result = await prisma.user.deleteMany({
                  where: { email: "fakebot@example.com" }
                });
                console.log(`üßπ Utilisateurs supprim√©s : ${result.count}`);
              } catch (e) {
                console.error("‚ùå √âchec de la suppression :", e.message);
                process.exit(1); // Exit with error code for better error handling
              } finally {
                await prisma.$disconnect();
              }
            }
            clean();
          EOT

            # 8.3.9.2 - Copier et ex√©cuter le script dans le conteneur
            echo "[INFO - 8.3.9.2] Copier et ex√©cuter le script dans le conteneur..."
            docker cp "$TEMP_SCRIPT" "$CONTAINER_NAME:/app/clean_test_user.js"  # Copier dans /app
            docker exec "$CONTAINER_NAME" node /app/clean_test_user.js  # Ex√©cuter dans /app

            # 8.3.9.3 - Supprimer le fichier dans le conteneur et localement
            echo "[INFO - 8.3.9.3] Supprimer le fichier dans le conteneur et localement..."
            docker exec "$CONTAINER_NAME" rm -f /app/clean_test_user.js  # Supprimer dans /app
            rm -f "$TEMP_SCRIPT"  # Supprimer localement


             # 8.4 - Mise √† jour de npm et Prisma
            echo "[INFO - 8.4] Mise √† jour de npm et Prisma..."
            docker exec "$CONTAINER_NAME" npm install -g npm@latest --force
            docker exec "$CONTAINER_NAME" npm install --save-dev prisma@latest @prisma/client@latest --force --legacy-peer-deps
                        
            # √âtape 8.4.1 - V√©rification des versions mises √† jour
            echo "[INFO - 8.4.1] V√©rification des versions de npm et Prisma..."
            docker exec "$CONTAINER_NAME" npm --version
            docker exec "$CONTAINER_NAME" npx prisma --version
            docker exec "$CONTAINER_NAME" npm list @prisma/client
            
            # 8.5 - Backup et migrations Prisma
            BACKUP_DIR="$(dirname "$MOUNT_PATH")/backup_bd"
            echo "[INFO - 8.5.1] Cr√©ation du r√©pertoire de backup : $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR"

            BACKUP_FILE="$BACKUP_DIR/backup_$(date +%Y%m%d%H%M%S).sql"
            echo "[INFO - 8.5.2] Cr√©ation du backup avant migration..."
            docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" -d "$DB_NAME" > "$BACKUP_FILE"

            # 8.5.3 - Validation du fichier schema.prisma
            echo "[INFO - 8.5.3] V√©rification du fichier schema.prisma..."

            # √âtape 8.5.3.0 - Recherche du fichier schema.prisma dans le conteneur
            echo "[INFO - 8.5.3.0] Recherche du fichier schema.prisma dans le conteneur..."
            SCHEMA_PATH=$(docker exec "$CONTAINER_NAME" find / -name "schema.prisma" 2>/dev/null | head -n 1)

            if [ -z "$SCHEMA_PATH" ]; then
              echo "[ERROR] Fichier schema.prisma introuvable dans le conteneur !" >&2
              echo "[INFO - 8.5.3.0] V√©rifiez que le fichier est inclus dans l'image Docker et que le chemin est correct."
              exit 1
            fi

            echo "[SUCCESS] Fichier schema.prisma trouv√© : $SCHEMA_PATH"

            # √âtape 8.5.3.1 - Validation syntaxique du sch√©ma
            echo "[INFO - 8.5.3.1] Validation syntaxique du sch√©ma..."
            docker exec "$CONTAINER_NAME" npx prisma validate --schema="$SCHEMA_PATH" || {
              echo "[ERROR] Le fichier schema.prisma est invalide. Corrigez les erreurs avant de continuer." >&2
              exit 1
            }
            echo "[SUCCESS] Le fichier schema.prisma est valide."

            # √âtape 8.5.3.2 - V√©rification des migrations Prisma en attente
            echo "[INFO - 8.5.3.2] V√©rification des migrations Prisma en attente..."
            docker exec "$CONTAINER_NAME" npx prisma migrate status --schema="$SCHEMA_PATH" || {
              echo "[WARNING] Des migrations sont en attente ou ont √©chou√©. V√©rifiez avant le d√©ploiement." >&2
            }


            # 8.5.4 - Application des migrations Prisma
            echo "[INFO - 8.5.4] Application des migrations Prisma..."

            # Identifier les migrations √©chou√©es
            FAILED_MIGRATIONS=$(docker exec "$CONTAINER_NAME" npx prisma migrate status | grep 'failed' | awk '{print $2}')

            if [ -n "$FAILED_MIGRATIONS" ]; then
              echo "[WARNING] Des migrations √©chou√©es d√©tect√©es : $FAILED_MIGRATIONS"
              for MIGRATION in $FAILED_MIGRATIONS; do
                echo "[INFO] Tentative de r√©solution pour : $MIGRATION"
                # R√©soudre la migration √©chou√©e (rollback ou marquer comme appliqu√©e)
                docker exec "$CONTAINER_NAME" npx prisma migrate resolve --rolled-back "$MIGRATION" || {
                  echo "[ERROR] √âchec de la r√©solution pour $MIGRATION." >&2
                  exit 1
                }
              done
            fi

            # Appliquer les migrations restantes
            docker exec "$CONTAINER_NAME" npx prisma migrate deploy || {
              echo "[ERROR] √âchec des migrations Prisma. Restauration du backup..." >&2
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d "$DB_NAME" < "$BACKUP_FILE" || {
                echo "[ERROR] √âchec de la restauration du backup. Intervention manuelle requise." >&2
                exit 1
              }
              exit 1
            }

            echo "[SUCCESS] Les migrations Prisma ont √©t√© appliqu√©es avec succ√®s."           

            # 8.6 - Nettoyage final
            echo "[INFO - 8.6] Nettoyage des anciens conteneurs et images..."
            docker container prune -f || echo "[WARNING] Nettoyage des conteneurs √©chou√©."
            docker image prune -f || echo "[WARNING] Nettoyage des images √©chou√©."

            echo "[SUCCESS] D√©ploiement backend termin√© avec succ√®s !"           
          
               
            # 8.7 - Suppression s√©curis√©e des fichiers temporaires
            echo "[INFO - 8.7] Suppression s√©curis√©e des fichiers temporaires..."
            rm -f /tmp/env_vars.sh /tmp/git_id_rsa
            echo "[SUCCESS] La suppression des fichiers temporaires est termin√©e !"

            # 8.8 - V√©rification testPrisma.js et des routes cl√©s
            echo "[INFO - 8.8] Ex√©cution de testPrisma.js pour tester Prisma..."
            docker exec $CONTAINER_NAME node tests/testPrisma.js

            # 8.9 - V√©rification de l'endpoint /health
            echo "[INFO - 8.9] üå°Ô∏è V√©rification de l'endpoint /health..."
            STATUS_CODE=$(docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "%{http_code}" http://localhost:$BACKEND_PORT/health)

            if [ "$STATUS_CODE" = "200" ]; then
              echo "[SUCCESS - 8.9] ‚úÖ L'endpoint /health a r√©pondu avec le code $STATUS_CODE"
            else
              echo "[ERROR - 8.9] ‚ùå L'endpoint /health a retourn√© $STATUS_CODE (attendu : 200)"
              exit 1
            fi

            # 8.10 - Test POST /api/register (sans payload r√©el)
            echo "[INFO - 8.10] üß™ Test POST /api/register (sans payload JSON)..."
            REGISTER_CODE=$(docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:$BACKEND_PORT/api/register)

            if [ "$REGISTER_CODE" = "415" ]; then
              echo "[SUCCESS - 8.10] ‚úÖ /api/register a bien renvoy√© $REGISTER_CODE ‚Äî comportement attendu sans JSON"
            else
              echo "[WARNING - 8.10] ‚ö†Ô∏è /api/register a renvoy√© $REGISTER_CODE (attendu : 415 si pas de payload)"
            fi

          EOF

      # √âtape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # √âtape 10 - Nettoyage des fichiers temporaires
      - name: 10 - Nettoyage des fichiers temporaires
        run: rm -f /tmp/git_id_rsa /tmp/env_vars.sh || true
