name: Déployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}     
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      # Étape 1 : Préparation initiale
      - name: 1 - Préparation initiale
        run: |
          echo "=== Début de la préparation initiale ==="
          echo "Création du répertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de créer le répertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "Répertoire de logs créé avec succès."
          echo "=== Fin de la préparation initiale ==="  
      # Étape 1.1 - Afficher les variables générées et valider leur présence
      - name: 1.1 - Afficher les variables générées
        run: |
          echo "[INFO] Affichage des variables générées : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET)
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done
      # Étape 2 - Récupérer le dépôt Git
      - name: 2 - Récupérer le dépôt
        uses: actions/checkout@v3
        

      # Étape 2.1 - Vérification après checkout
      - name: 2.1 - Vérification après checkout
        run: |
          echo "[INFO] Vérification après le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable à la racine. Vérifiez la structure du dépôt." && exit 1
          fi
      # Étape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.1'

      # Étape 3 - Installer les dépendances et valider l'arbre de dépendances
      - name: 3 - Installer les dépendances et valider l'arbre de dépendances
        run: |
          echo "[INFO - 3.1] Création du répertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de créer le répertoire des logs." && exit 1)
          echo "[INFO - 3.2] Installation des dépendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi
          echo "[INFO - 3.3] Validation des vulnérabilités..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique échoué. À vérifier manuellement."
          }
          echo "[INFO - 3.4] Validation de l'arbre des dépendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de dépendances invalide détecté. Régénération en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de dépendances valide."
          fi
          echo "[SUCCESS - 3.5] Dépendances prêtes pour le build Docker."
      # Étape 4 - Construire l'image Docker pour le backend
      - name: 4 - Construire l'image Docker
        run: |
          echo "[INFO - 4.1] Nettoyage des images Docker inutilisées..."
          docker image prune -f || (echo "[ERROR - 4.1] Impossible de nettoyer les images Docker." && exit 1)
          echo "[INFO - 4.2] Construction de l'image Docker pour le backend..."
          docker build -t $DOCKER_NAME -f Dockerfile.backend . | tee -a logs/backend_deploy.log || exit 1
          echo "[INFO - 4.3] Validation du build Docker..."
          docker images $DOCKER_NAME || (echo "[ERROR - 4.3] L'image Docker $DOCKER_NAME n'a pas été construite avec succès." && exit 1)
          echo "[SUCCESS - 4.4] Image Docker construite avec succès : $DOCKER_NAME."
        
      # Étape 5 - Démarrer l'agent SSH et ajouter la clé 
      - name: 5 - Démarrer l'agent SSH et ajouter la clé
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Clé SSH invalide." && exit 1)
        
      # Étape 6 - Configuration du conteneur PostgreSQL      
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          echo "=== Étape 6 : Configuration du conteneur PostgreSQL ==="

          # Sous-étape 6.1 : Créer un fichier temporaire contenant les variables nécessaires
          echo "[INFO - Sous-étape 6.1] Création du fichier temporaire contenant les variables..."
          cat <<EOT > /tmp/env_vars.sh
          ENV=$ENV
          NETWORK=$NETWORK
          POSTGRES_VOLUME=$POSTGRES_VOLUME
          POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME
          DB_USERNAME=$DB_USERNAME
          DB_PASSWORD=$DB_PASSWORD
          DB_NAME=$DB_NAME
          DB_PORT_INT=$DB_PORT_INT
          DB_PORT_EXT=$DB_PORT_EXT
          EOT

          # Vérification de la création du fichier temporaire
          if [ ! -f /tmp/env_vars.sh ]; then
            echo "[ERROR] Échec de la création du fichier temporaire /tmp/env_vars.sh." >&2
            exit 1
          fi

          # Sous-étape 6.2 : Copier le fichier temporaire vers le serveur distant
          echo "[INFO - Sous-étape 6.2] Envoi du fichier temporaire contenant les variables au serveur distant..."
          scp -P "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no /tmp/env_vars.sh "$SSH_USER@$SERVER_IP:/tmp/env_vars.sh"

          # Sous-étape 6.3 : Connexion SSH et exécution des commandes sur le serveur distant
          ssh -p "$SSH_PORT" -i /tmp/git_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" << 'EOF'
          set -e

          # Sous-étape 6.3.1 : Charger les variables depuis le fichier temporaire
          echo "[INFO - Sous-étape 6.3.1] Chargement des variables depuis le fichier temporaire..."
          if [ -f /tmp/env_vars.sh ]; then
            source /tmp/env_vars.sh
          else
            echo "[ERROR] Le fichier /tmp/env_vars.sh est introuvable." >&2
            exit 1
          fi

          # Sous-étape 6.3.2 : Vérification des variables chargées
          echo "[INFO - Sous-étape 6.3.2] Vérification des variables chargées..."
          MANDATORY_VARS=(ENV NETWORK POSTGRES_VOLUME POSTGRES_CONTAINER_NAME DB_USERNAME DB_PASSWORD DB_NAME DB_PORT_INT DB_PORT_EXT)
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "\${!VAR}" ]; then
              echo "[ERROR] La variable \$VAR est manquante ou vide." >&2
              exit 1
            fi
            echo "[INFO] \$VAR=\${!VAR}"
          done

          # Sous-étape 6.3.3 : Vérifier et créer le réseau Docker
          echo "[INFO - Sous-étape 6.3.3] Vérification/création du réseau Docker..."
          if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
            docker network create "$NETWORK" || { echo "[ERROR] Impossible de créer le réseau Docker."; exit 1; }
          else
            echo "[INFO] Réseau Docker déjà existant : $NETWORK"
          fi

          # Sous-étape 6.3.4 : Vérifier et créer le volume Docker
          echo "[INFO - Sous-étape 6.3.4] Vérification/création du volume Docker..."
          if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
            docker volume create "$POSTGRES_VOLUME" || { echo "[ERROR] Impossible de créer le volume Docker."; exit 1; }
          else
            echo "[INFO] Volume Docker déjà existant : $POSTGRES_VOLUME"
          fi

          # Sous-étape 6.3.5 : Arrêter et supprimer le conteneur PostgreSQL existant
          echo "[INFO - Sous-étape 6.3.5] Arrêt/suppression du conteneur PostgreSQL existant..."
          if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
            docker stop "$POSTGRES_CONTAINER_NAME" || echo "[WARNING] Échec de l'arrêt du conteneur."
            docker rm "$POSTGRES_CONTAINER_NAME" || echo "[WARNING] Échec de la suppression du conteneur."
          fi

          # Sous-étape 6.3.6 : Lancer un nouveau conteneur PostgreSQL
          echo "[INFO - Sous-étape 6.3.6] Lancement du conteneur PostgreSQL..."
          docker run -d --name "$POSTGRES_CONTAINER_NAME" \
            --network "$NETWORK" \
            -e POSTGRES_USER="$DB_USERNAME" \
            -e POSTGRES_PASSWORD="$DB_PASSWORD" \
            -e POSTGRES_DB="$DB_NAME" \
            -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
            -p "$DB_PORT_EXT:$DB_PORT_INT" \
            postgres:13 || { echo "[ERROR] Échec du lancement du conteneur PostgreSQL."; exit 1; }

          # Sous-étape 6.3.7 : Vérification finale que PostgreSQL est prêt
          echo "[INFO - Sous-étape 6.3.7] Vérification que PostgreSQL est prêt..."
          for i in {1..10}; do
            if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U postgres -d postgres; then
              echo "[INFO] PostgreSQL est prêt."
              break
            else
              echo "[INFO] En attente... (tentative $i/10)"
              sleep 5
            fi
          done

          if [ "$i" -eq 10 ]; then
            echo "[ERROR] PostgreSQL n'a pas démarré après 10 tentatives." >&2
            exit 1
          fi

          # Étape 6.3.7.0 : Création du rôle si nécessaire
          echo "[INFO - Sous-étape 6.3.7.0] Vérification/création du rôle utilisateur..."
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || \
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE $DB_USERNAME WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          echo "[INFO] Rôle utilisateur '$DB_USERNAME' vérifié/créé avec succès."

          # Étape 6.3.7.1 - Création de la base de données si elle n'existe pas
          echo '[INFO - Sous-étape 6.3.7.1] Vérification/création de la base de données...'
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USERNAME;"
          echo "[INFO] Base de données '$DB_NAME' vérifiée/créée avec succès."

          # Sous-étape 6.3.8 : Vérification et création du rôle postgres
          echo "[INFO - Sous-étape 6.3.8] Vérification du rôle 'postgres'..."
          if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='postgres';" | grep -q 1; then
            echo "[INFO] Création du rôle 'postgres'..."
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';"
          else
            echo "[INFO] Le rôle 'postgres' existe déjà."
          fi

          # Sous-étape 6.3.9 : Ajout des vérifications supplémentaires après création des rôles
          echo "[INFO - Sous-étape 6.3.9] Vérifications supplémentaires après la création des rôles..."
          docker inspect "$POSTGRES_CONTAINER_NAME" | grep -A 10 "Env"
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c '\l'
          docker exec "$POSTGRES_CONTAINER_NAME" psql -U postgres -c '\du'
          docker logs "$POSTGRES_CONTAINER_NAME"

          # Suppression du fichier temporaire
          echo "[INFO - Sous-étape 6.3.10] Suppression du fichier temporaire..."
          rm -f /tmp/env_vars.sh      
          EOF

          # Sous-étape 6.4 : Nettoyer le fichier temporaire local
          echo "[INFO - 6.4] Suppression du fichier temporaire local..."
          rm -f /tmp/env_vars.sh

      # Étape 7 - Création de la base de données et des utilisateurs
      - name: 7 - Création de la base de données et des utilisateurs
        run: |
          echo "=== Étape 7 : Création de la base de données et des utilisateurs ==="

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - Étape 7] Création des utilisateurs et de la base de données...' | tee -a "$LOG_FILE"
            
            # Vérification et création du rôle si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] Rôle créé : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # Vérification et création de la base de données si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de données créée : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] Étape 7 terminée avec succès.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - Déployer le conteneur Backend
        run: |
          echo "=== Étape 8 : Déploiement du backend ==="
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT_INT}/${DB_NAME}"
          echo "[INFO] DATABASE_URL construit : $DATABASE_URL"

          # Passer toutes les variables comme arguments dans la session SSH
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" \
          "ENV='$ENV' DATABASE_URL='$DATABASE_URL' JWT_SECRET='$JWT_SECRET' BACKEND_PORT='$BACKEND_PORT' MOUNT_PATH='$MOUNT_PATH' POSTGRES_CONTAINER_NAME='$POSTGRES_CONTAINER_NAME' DB_USERNAME='$DB_USERNAME' DB_NAME='$DB_NAME' CONTAINER_NAME='$CONTAINER_NAME' NETWORK='$NETWORK' DOCKER_NAME='$DOCKER_NAME' DB_PASSWORD='$DB_PASSWORD' bash -s" << 'EOF'
            set -e

            # Sous-étape 8.0 : Vérification des variables chargées
            echo "[INFO - Sous-étape 8.0] Vérification des variables chargées..."
            MANDATORY_VARS=(ENV DATABASE_URL JWT_SECRET BACKEND_PORT MOUNT_PATH)
            for VAR in "${MANDATORY_VARS[@]}"; do
              VALUE=$(eval echo "\$$VAR")
              if [ -z "$VALUE" ]; then
                echo "[ERROR] La variable $VAR est manquante ou vide." >&2
                exit 1
              fi
              echo "[INFO] $VAR=$VALUE"
            done

            echo "[SUCCESS] Toutes les variables nécessaires sont définies."

            # Sous-étape 8.1 : Suppression de l’ancien conteneur backend
            echo '[INFO - Sous-étape 8.1] Suppression de l’ancien conteneur backend...'
            if docker ps -a --filter "name=$CONTAINER_NAME" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              docker stop "$CONTAINER_NAME" || echo '[WARNING] Échec de l’arrêt du conteneur.'
              docker rm "$CONTAINER_NAME" || echo '[WARNING] Échec de la suppression du conteneur.'
            fi

            # Sous-étape 8.2 : Lancement du conteneur backend
            echo '[INFO - Sous-étape 8.2] Lancement du nouveau conteneur backend...'
            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH/.env:/app/.env" \
              -v "$MOUNT_PATH/logs:/app/logs" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "$BACKEND_PORT:$BACKEND_PORT" \
              "$DOCKER_NAME" || {
                echo '[ERROR] Échec du démarrage du conteneur backend.' >&2
                exit 1
            }

            # Sous-étape 8.3 : Vérification que le conteneur est actif
            echo '[INFO - Sous-étape 8.3] Vérification que le conteneur est actif...'
            if docker ps --filter "name=$CONTAINER_NAME" --filter "status=running" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              echo '[SUCCESS] Le conteneur backend est actif et opérationnel.'
            else
              echo '[ERROR] Le conteneur backend n’est pas opérationnel.' >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            fi

            # Sous-étape 8.4 : Création et vérification du fichier .env
            echo '[INFO - Sous-étape 8.4] Création et vérification du fichier .env...'
            cat <<EOT > "$MOUNT_PATH/.env"
            DATABASE_URL=$DATABASE_URL
            NODE_ENV=$ENV
            JWT_SECRET=$JWT_SECRET
            SERVER_PORT=$BACKEND_PORT
          EOT
            cat "$MOUNT_PATH/.env"

            # Sous-étape 8.4.1 : Nettoyage des logs
            echo '[INFO - Sous-étape 8.6] Vérification et création du répertoire de logs...'
            mkdir -p "$MOUNT_PATH/logs"

            # Étape 8.5 - Suppression de l’ancien conteneur
            echo '[INFO - Étape 8.5] Suppression de l’ancien conteneur...'
            if docker ps -a --filter "name=$CONTAINER_NAME" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              docker stop "$CONTAINER_NAME" || echo '[WARNING] Échec de l’arrêt du conteneur.'
              docker rm "$CONTAINER_NAME" || echo '[WARNING] Échec de la suppression du conteneur.'
            fi

            # Étape 8.6 - Lancement du nouveau conteneur backend
            echo '[INFO - Étape 8.6] Lancement du conteneur backend...'
            docker run -d --name "$CONTAINER_NAME" \
              --network "$NETWORK" \
              -v "$MOUNT_PATH/.env:/app/.env" \
              -v "$MOUNT_PATH/logs:/app/logs" \
              -w /app \
              --env-file "$MOUNT_PATH/.env" \
              -p "$BACKEND_PORT:$BACKEND_PORT" \
              "$DOCKER_NAME" || {
                echo '[ERROR] Échec du démarrage du conteneur backend.' >&2
                exit 1
            }

            # Étape 8.7 - Vérification que le conteneur est actif.
            echo '[INFO - Étape 8.7] Vérification que le conteneur est actif...'
            if docker ps --filter "name=$CONTAINER_NAME" --filter "status=running" --format '{{.Names}}' | grep -w "$CONTAINER_NAME"; then
              echo '[SUCCESS] Le conteneur backend est actif et opérationnel.'
            else
              echo '[ERROR] Le conteneur backend n’est pas opérationnel.' >&2
              docker logs "$CONTAINER_NAME"
              exit 1
            fi

            # Étape 8.8 : Mise à jour de npm et Prisma avant les migrations
            echo "[INFO] Vérification des variables SSH..."
            if [ -z "$SSH_PORT" ] || [ -z "$SSH_USER" ] || [ -z "$SERVER_IP" ] || [ -z "$MOUNT_PATH" ]; then
              echo "[ERROR] Une ou plusieurs variables SSH ne sont pas définies." >&2
              exit 1
            else
              echo "[SUCCESS] Toutes les variables SSH sont correctement définies."
            fi

            echo "[INFO - Étape 8.8.0] Mise à jour de npm et Prisma..."

            # Mise à jour de npm à la dernière version
            echo "[INFO] Mise à jour de npm à la dernière version..."
            docker exec "$CONTAINER_NAME" npm install -g npm@latest --force

            # Mise à jour de Prisma et @prisma/client
            echo "[INFO] Mise à jour de Prisma et @prisma/client..."
            docker exec "$CONTAINER_NAME" npm install --save-dev prisma@latest @prisma/client@latest --force --legacy-peer-deps

            # Vérification des versions mises à jour
            echo "[INFO] Vérification des versions de npm et Prisma..."
            docker exec "$CONTAINER_NAME" npm --version
            docker exec "$CONTAINER_NAME" npx prisma --version
            docker exec "$CONTAINER_NAME" npm list @prisma/client

            # Étape 8.8.0 : Mise à jour de npm et Prisma
            echo "[INFO - Étape 8.8.0] Mise à jour de npm et Prisma..."

            # Nouvelle étape : Synchroniser le fichier schema.prisma
            echo "[INFO] Synchronisation du fichier schema.prisma vers le serveur..."
            scp -P "$SSH_PORT" -i /tmp/git_id_rsa \
              -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no \
              prisma/schema.prisma "$SSH_USER@$SERVER_IP:$MOUNT_PATH/prisma/schema.prisma" || {
                echo "[ERROR] Échec de la synchronisation du fichier schema.prisma." >&2
                exit 1
              }
            echo "[SUCCESS] Fichier schema.prisma synchronisé avec succès."

            # Continuer avec les migrations Prisma
            echo "[INFO - Étape 8.8.1] Définition du répertoire de backup..."

            # Étape 8.8.1 - Définir le répertoire de backup
            echo '[INFO - Étape 8.8.1] Définition du répertoire de backup...'
            BACKUP_DIR="$(dirname "$MOUNT_PATH")/backup_bd"

            # Vérification stricte de BACKUP_DIR
            if [ -z "$BACKUP_DIR" ] || [ "$BACKUP_DIR" = "/" ]; then
              echo "[ERROR] Impossible de déterminer BACKUP_DIR à partir de MOUNT_PATH." >&2
              exit 1
            fi

            # Création du répertoire de backup s'il n'existe pas
            echo "[INFO] Création du répertoire de backup : $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR" || {
              echo "[ERROR] Échec de la création du répertoire de backup : $BACKUP_DIR" >&2
              exit 1
            }
            echo "[SUCCESS] Répertoire de backup prêt : $BACKUP_DIR"

              # Étape 8.8.2 - Backup de la base de données avant les migrations
              echo '[INFO - Étape 8.8.2] Création d’un backup de la base de données avant migration...'
              BACKUP_FILE="$BACKUP_DIR/backup_$(date +%Y%m%d%H%M%S).sql"
              docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" -d "$DB_NAME" > "$BACKUP_FILE" || {
                echo '[ERROR] Échec de la création du backup. Migration annulée.' >&2
                exit 1
              }
              echo "[INFO] Backup créé : $BACKUP_FILE"
      
            # Étape 8.8.3 - Vérification des migrations échouées
            echo '[INFO - Étape 8.8.3] Vérification des migrations échouées...'
            FAILED_MIGRATION=$(docker exec "$CONTAINER_NAME" npx prisma migrate status | grep 'failed' | awk '{print $2}')

            if [ -n "$FAILED_MIGRATION" ]; then
              echo "[WARNING] Migration échouée détectée : $FAILED_MIGRATION"
              for MIGRATION in $FAILED_MIGRATION; do
                echo "[INFO - Étape 8.8.3.1] Résolution de la migration échouée : $MIGRATION"
                docker exec "$CONTAINER_NAME" npx prisma migrate resolve --applied "$MIGRATION" || {
                  echo "[ERROR] Échec de la résolution de la migration : $MIGRATION" >&2
                  exit 1
                }
              done
            else
              echo "[INFO] Aucune migration échouée détectée."
            fi
      
            # Étape 8.8.4 - Application des migrations Prisma
            echo '[INFO - Étape 8.8.4] Application des migrations Prisma...'
            docker exec "$CONTAINER_NAME" npx prisma migrate deploy || {
              echo '[ERROR] Échec du déploiement des migrations Prisma. Restauration du backup...' >&2
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d "$DB_NAME" < "$BACKUP_FILE" || {
                echo "[ERROR] Échec de la restauration du backup. Vérification manuelle requise." >&2
                exit 1
              }
              exit 1
            }
            echo "[SUCCESS] Les migrations Prisma ont été appliquées avec succès."
      
            # Étape 8.8.5 - Vérification finale des migrations
            echo '[INFO - Étape 8.8.5] Vérification finale de l’état des migrations Prisma...'
            docker exec "$CONTAINER_NAME" npx prisma migrate status || {
              echo '[ERROR] Les migrations ne sont pas dans un état cohérent.' >&2
              exit 1
            }
            echo "[SUCCESS] Vérification des migrations terminée avec succès."
      
            # Étape 8.8.6 - Nettoyage des anciens conteneurs et images
            echo '[INFO - Étape 8.8.6] Nettoyage des anciens conteneurs et des images non utilisées...'
            docker container prune -f || echo "[WARNING] Nettoyage des conteneurs échoué."
            docker image prune -f || echo "[WARNING] Nettoyage des images échoué."
      
            # Étape 8.8.7 - Confirmation finale
            echo '[SUCCESS - Étape 8.8.7] Migrations Prisma appliquées avec succès, backup sauvegardé dans un répertoire dédié.' 
            echo "[SUCCESS] Déploiement backend terminé avec succès !"           
            
          EOF

      # Étape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # Étape 10 - Nettoyage des fichiers temporaires
      - name: Nettoyer les fichiers temporaires
        run: rm -f /tmp/git_id_rsa