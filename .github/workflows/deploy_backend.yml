name: Déployer Backend

on:
  push:
    branches:
      - dev
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'prod' || 'dev' }}

    env:
      ENV: ${{ vars.ENV }}
      LOG_FILE: backend/logs/backend_deploy_${{ vars.ENV }}.log
      DB_PORT_INT: ${{ vars.DB_PORT_INT }}
      DB_PORT_EXT: ${{ vars.DB_PORT_EXT }}
      BACKEND_PORT: ${{ vars.BACKEND_PORT }}
      DB_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      DB_HOST: ${{ vars.DB_POST }}_${{ vars.ENV }}
      NETWORK: ${{ vars.NET }}_${{ vars.ENV }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USER: ${{ secrets.SSH_USER }}     
      DB_USERNAME: ${{ vars.USR_DB }}_${{ vars.ENV }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      POSTGRES_CONTAINER_NAME: ${{ vars.DB_POST }}_${{ vars.ENV }}
      POSTGRES_VOLUME: ${{ vars.DB_POST }}_${{ vars.DATA }}_${{ vars.ENV }}
      CONTAINER_NAME: ${{ vars.BACK }}_${{ vars.NODE }}_${{ vars.ENV }}
      MOUNT_PATH: ${{ secrets.MOUNT_PATH }}
      DATABASE_URL: "postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      DOCKER_NAME: back_node:latest
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      # Étape 1 : Préparation initiale
      - name: 1 - Préparation initiale
        run: |
          echo "=== Début de la préparation initiale ==="
          echo "Création du répertoire de logs..."
          mkdir -p backend/logs || (echo "Erreur : Impossible de créer le répertoire des logs." && exit 1)
          chmod -R 777 backend/logs
          echo "Répertoire de logs créé avec succès."
          echo "=== Fin de la préparation initiale ==="  

      # Étape 1.1 - Afficher les variables générées et valider leur présence
      - name: 1.1 - Afficher les variables générées
        run: |
          echo "[INFO] Affichage des variables générées : " | tee -a $LOG_FILE
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET)
          for VAR in "${MANDATORY_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              echo "[ERROR] La variable $VAR est manquante ou vide." | tee -a $LOG_FILE
              exit 1
            fi
            echo "[INFO] $VAR=${!VAR}" | tee -a $LOG_FILE
          done

      # Étape 2 - Récupérer le dépôt Git
      - name: 2 - Récupérer le dépôt
        uses: actions/checkout@v3
        

      # Étape 2.1 - Vérification après checkout
      - name: 2.1 - Vérification après checkout
        run: |
          echo "[INFO] Vérification après le checkout..."
          ls -la
          if [ ! -f package.json ]; then
            echo "[ERROR] Fichier package.json introuvable à la racine. Vérifiez la structure du dépôt." && exit 1
          fi

      # Étape 2.2 - Configurer la version de Node.js
      - name: 2.2 - Configurer Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.1'

      # Étape 3 - Installer les dépendances et valider l'arbre de dépendances
      - name: 3 - Installer les dépendances et valider l'arbre de dépendances
        run: |
          echo "[INFO - 3.1] Création du répertoire des logs..."
          mkdir -p logs || (echo "[ERROR - 3.1] Impossible de créer le répertoire des logs." && exit 1)

          echo "[INFO - 3.2] Installation des dépendances pour l'environnement $ENV..."
          if [ "$ENV" = "prod" ]; then
            npm install --omit=dev --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          fi

          echo "[INFO - 3.3] Validation des vulnérabilités..."
          npm audit --loglevel=warn | tee -a logs/backend_deploy.log || {
            echo "[WARNING - 3.3] Audit automatique échoué. À vérifier manuellement."
          }

          echo "[INFO - 3.4] Validation de l'arbre des dépendances..."
          if grep -q 'Invalid package tree' logs/backend_deploy.log; then
            echo "[WARNING - 3.4] Arbre de dépendances invalide détecté. Régénération en cours..."
            rm -rf node_modules package-lock.json
            npm install --loglevel=warn | tee -a logs/backend_deploy.log || exit 1
          else
            echo "[INFO - 3.4] Arbre de dépendances valide."
          fi

          echo "[SUCCESS - 3.5] Dépendances prêtes pour le build Docker."

      # Étape 4 - Construire l'image Docker pour le backend
      - name: 4 - Construire l'image Docker
        run: |
          echo "[INFO - 4.1] Nettoyage des images Docker inutilisées..."
          docker image prune -f || (echo "[ERROR - 4.1] Impossible de nettoyer les images Docker." && exit 1)

          echo "[INFO - 4.2] Construction de l'image Docker pour le backend..."
          docker build -t $DOCKER_NAME -f Dockerfile.backend . | tee -a logs/backend_deploy.log || exit 1

          echo "[INFO - 4.3] Validation du build Docker..."
          docker images $DOCKER_NAME || (echo "[ERROR - 4.3] L'image Docker $DOCKER_NAME n'a pas été construite avec succès." && exit 1)

          echo "[SUCCESS - 4.4] Image Docker construite avec succès : $DOCKER_NAME."
        
      # Étape 5 - Démarrer l'agent SSH et ajouter la clé 
      - name: 5 - Démarrer l'agent SSH et ajouter la clé
        run: |
          echo "$SSH_PRIVATE_KEY" > /tmp/git_id_rsa
          chmod 600 /tmp/git_id_rsa
          eval $(ssh-agent -s)
          ssh-add /tmp/git_id_rsa || (echo "Erreur : Clé SSH invalide." && exit 1)
        
      # Étape 6 - Configuration du conteneur PostgreSQL
      - name: 6 - Configuration du conteneur PostgreSQL
        run: |
          # === Étape 6 : Configuration du conteneur PostgreSQL ===
          echo "=== Étape 6 : Configuration du conteneur PostgreSQL ==="

          # 6.1 - Préparation initiale
          echo "[INFO - 6.1] Préparation initiale..."
          if ! mkdir -p backend/logs; then
            echo "[ERROR - 6.1] Impossible de créer le répertoire des logs."
            exit 1
          fi
          chmod -R 777 backend/logs

          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e

            echo '===================================' | tee -a "$LOG_FILE"
            echo '[INFO - Étape 6] Début de la configuration PostgreSQL...' | tee -a "$LOG_FILE"

            # 6.2 - Sauvegarde conditionnelle (prod et dev)
            echo '[INFO - 6.2.1] Préparation de la sauvegarde de la base de données...' | tee -a "$LOG_FILE"
            if [ "$ENV" == "prod" ]; then
              BACKUP_DIR="/home/$SSH_USER/backups/prod"
              BACKUP_FILE="\$BACKUP_DIR/prod_backup_\$(date +%Y%m%d%H%M%S).sql"
            else
              BACKUP_DIR="/home/$SSH_USER/backups/dev"
              BACKUP_FILE="\$BACKUP_DIR/dev_backup_\$(date +%Y%m%d%H%M%S).sql"
            fi

            # Création du répertoire de sauvegarde
            mkdir -p "\$BACKUP_DIR"

            # Vérification si le conteneur PostgreSQL est en cours d'exécution
            if docker ps --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
              echo '[INFO - 6.2.2] Conteneur PostgreSQL en cours d’exécution. Début de la sauvegarde...' | tee -a "$LOG_FILE"
              if ! docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" "$DB_NAME" > "\$BACKUP_FILE"; then
                echo '[ERROR - 6.2.3] Échec de la sauvegarde de la base de données.' | tee -a "$LOG_FILE"
                exit 1
              fi
              echo "[INFO - 6.2.4] Sauvegarde effectuée avec succès : \$BACKUP_FILE" | tee -a "$LOG_FILE"
            else
              echo '[WARNING - 6.2.5] Le conteneur PostgreSQL n’est pas en cours d’exécution. Tentative de redémarrage...' | tee -a "$LOG_FILE"
              docker start "$POSTGRES_CONTAINER_NAME" || {
                echo '[ERROR - 6.2.6] Impossible de redémarrer le conteneur PostgreSQL. Sauvegarde annulée.' | tee -a "$LOG_FILE"
                exit 1
              }
              echo '[INFO - 6.2.7] Conteneur PostgreSQL redémarré. Début de la sauvegarde...' | tee -a "$LOG_FILE"
              if ! docker exec "$POSTGRES_CONTAINER_NAME" pg_dump -U "$DB_USERNAME" "$DB_NAME" > "\$BACKUP_FILE"; then
                echo '[ERROR - 6.2.8] Échec de la sauvegarde de la base de données après redémarrage.' | tee -a "$LOG_FILE"
                exit 1
              fi
              echo "[INFO - 6.2.9] Sauvegarde effectuée avec succès : \$BACKUP_FILE" | tee -a "$LOG_FILE"
            fi

            # 6.3 - Nettoyage des anciens backups
            echo '[INFO - 6.3] Nettoyage des anciens backups (plus de 7 jours)...' | tee -a "$LOG_FILE"
            find "\$BACKUP_DIR" -name '*.sql' -type f -mtime +7 -exec rm -f {} \;
            echo '[INFO - 6.3.1] Nettoyage terminé.' | tee -a "$LOG_FILE"

            # 6.4 - Vérification et création du réseau Docker
            echo '[INFO - 6.4] Vérification et création du réseau Docker...' | tee -a "$LOG_FILE"
            if ! docker network ls --filter "name=^$NETWORK\$" --format '{{.Name}}' | grep -w "$NETWORK"; then
              docker network create "$NETWORK"
              echo '[INFO - 6.4.1] Réseau Docker créé : $NETWORK' | tee -a "$LOG_FILE"
            else
              echo '[INFO - 6.4.2] Réseau Docker déjà existant : $NETWORK' | tee -a "$LOG_FILE"
            fi

            # 6.5 - Vérification et création du volume Docker
            echo '[INFO - 6.5] Vérification et création du volume Docker...' | tee -a "$LOG_FILE"
            if ! docker volume ls --filter "name=^$POSTGRES_VOLUME\$" --format '{{.Name}}' | grep -w "$POSTGRES_VOLUME"; then
              docker volume create "$POSTGRES_VOLUME"
              echo '[INFO - 6.5.1] Volume Docker créé : $POSTGRES_VOLUME' | tee -a "$LOG_FILE"
            else
              echo '[INFO - 6.5.2] Volume Docker déjà existant : $POSTGRES_VOLUME' | tee -a "$LOG_FILE"
            fi

            # 6.6 - Arrêt et suppression de l’ancien conteneur PostgreSQL
            echo '[INFO - 6.6] Arrêt et suppression de l’ancien conteneur PostgreSQL...' | tee -a "$LOG_FILE"
            if docker ps -a --filter "name=$POSTGRES_CONTAINER_NAME" --format '{{.Names}}' | grep -w "$POSTGRES_CONTAINER_NAME"; then
              docker stop "$POSTGRES_CONTAINER_NAME"
              docker rm "$POSTGRES_CONTAINER_NAME"              
            fi

            # Suppression du volume associé
            echo '[INFO - 6.6.1] Suppression du volume Docker...' | tee -a "$LOG_FILE"
            docker volume rm "${POSTGRES_VOLUME}" || {
              echo '[WARNING - 6.6.2] Échec de la suppression du volume Docker. Il est peut-être déjà supprimé.' | tee -a "$LOG_FILE"
            }

            # 6.7 - Téléchargement de l’image PostgreSQL
            echo '[INFO - 6.7] Téléchargement de l’image PostgreSQL...' | tee -a "$LOG_FILE"
            docker pull postgres:13

            # 6.8 - Démarrage de PostgreSQL sans volume initial
            echo '[INFO - 6.8] Démarrage du conteneur PostgreSQL sans volume initial...' | tee -a "$LOG_FILE"
            docker run -d --name "$POSTGRES_CONTAINER_NAME" \
              --network "$NETWORK" \
              -e POSTGRES_USER="$DB_USERNAME" \
              -e POSTGRES_PASSWORD="$DB_PASSWORD" \
              -e POSTGRES_DB="$DB_NAME" \
              -p "$DB_PORT_EXT:$DB_PORT_INT" \
              postgres:13 || {
              echo '[ERROR - 6.8] Échec du lancement du conteneur PostgreSQL sans volume.' | tee -a "$LOG_FILE"
              exit 1
            }

            # 6.9 - Attendre que PostgreSQL soit prêt
            echo '[INFO - 6.9] Attente de l’initialisation de PostgreSQL...' | tee -a "$LOG_FILE"
            sleep 10  # Ajustez ce délai selon votre environnement
            if ! docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U "$DB_USERNAME"; then
              echo '[ERROR - 6.9] PostgreSQL n’est pas prêt après l’initialisation.' | tee -a "$LOG_FILE"
              exit 1
            fi

            # 6.10 - Configuration des rôles et utilisateurs nécessaires
            echo '[INFO - 6.10] Configuration des rôles et utilisateurs nécessaires...' | tee -a "$LOG_FILE"
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '$DB_PASSWORD';" || {
              echo '[ERROR - 6.10] Échec de la création du rôle postgres.' | tee -a "$LOG_FILE"
              exit 1
            }

            # Vérifiez si la base de données définie par POSTGRES_DB existe
            echo '[INFO - 6.10.1] Vérification de la base de données définie par POSTGRES_DB...' | tee -a "$LOG_FILE"
            if ! docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -d postgres -c "\l" | grep -qw "$DB_NAME"; then
              echo "[ERROR - 6.10.2] La base de données '$DB_NAME' n'existe pas." | tee -a "$LOG_FILE"
              exit 1
            else
              echo "[SUCCESS - 6.10.3] La base de données '$DB_NAME' existe." | tee -a "$LOG_FILE"
            fi

            # 6.11 - Arrêt du conteneur PostgreSQL
            echo '[INFO - 6.11] Arrêt du conteneur PostgreSQL...' | tee -a "$LOG_FILE"
            docker stop "$POSTGRES_CONTAINER_NAME" || {
              echo '[ERROR - 6.11] Échec de l’arrêt du conteneur PostgreSQL.' | tee -a "$LOG_FILE"
              exit 1
            }

            # 6.12 - Copie des données initialisées dans le volume Docker
            echo '[INFO - 6.12] Copie des données initialisées dans le volume Docker...' | tee -a "$LOG_FILE"
            docker run --rm --volumes-from "$POSTGRES_CONTAINER_NAME" -v "$POSTGRES_VOLUME:/backup" busybox sh -c "cp -R /var/lib/postgresql/data /backup" || {
              echo '[ERROR - 6.12] Échec de la copie des données initialisées.' | tee -a "$LOG_FILE"
              exit 1
            }

            # Suppression complète du volume Docker avant le redémarrage
            docker volume rm "${POSTGRES_VOLUME}" || {
              echo "[WARNING] Le volume Docker '${POSTGRES_VOLUME}' n'a pas pu être supprimé. Il peut être déjà inexistant."
            }
            docker volume create "${POSTGRES_VOLUME}" || {
              echo "[ERROR] Impossible de recréer le volume '${POSTGRES_VOLUME}'."
              exit 1
            }

            # 6.13 - Relancer PostgreSQL avec le volume monté
            echo '[INFO - 6.13] Relancer le conteneur PostgreSQL avec le volume monté...' | tee -a "$LOG_FILE"

            # Supprimer le conteneur arrêté avant de relancer
            docker rm "$POSTGRES_CONTAINER_NAME" || {
              echo '[WARNING - 6.13.1] Échec de la suppression du conteneur arrêté. Il est peut-être déjà supprimé.' | tee -a "$LOG_FILE"
            }

            # Relancer le conteneur
            docker run -d --name "$POSTGRES_CONTAINER_NAME" \
              --network "$NETWORK" \
              -e POSTGRES_USER="$DB_USERNAME" \
              -e POSTGRES_PASSWORD="$DB_PASSWORD" \
              -e POSTGRES_DB="$DB_NAME" \
              -v "$POSTGRES_VOLUME:/var/lib/postgresql/data" \
              -p "$DB_PORT_EXT:$DB_PORT_INT" \
              postgres:13 || {
              echo '[ERROR - 6.13] Échec du lancement du conteneur PostgreSQL avec le volume monté.' | tee -a "$LOG_FILE"
              exit 1
            }

            # 6.14 - Vérification finale de PostgreSQL
            echo '[INFO - 6.14] Vérification finale de PostgreSQL...' | tee -a "$LOG_FILE"

            ATTEMPTS=10
            SLEEP_TIME=3

            for ((i=1; i<=ATTEMPTS; i++)); do
              echo "[INFO - 6.14.$i] Vérification de PostgreSQL (tentative $i/$ATTEMPTS)..." | tee -a "$LOG_FILE"
              if docker exec "$POSTGRES_CONTAINER_NAME" pg_isready -U "$DB_USERNAME"; then
                echo '[SUCCESS - 6.14] PostgreSQL est prêt et fonctionne correctement.' | tee -a "$LOG_FILE"
                break
              else
                echo "[WARNING - 6.14.$i] PostgreSQL n’est pas encore prêt. Nouvelle tentative dans $SLEEP_TIME secondes..." | tee -a "$LOG_FILE"
                sleep "$SLEEP_TIME"
              fi
              
              # Si la dernière tentative échoue
              if [ "$i" -eq "$ATTEMPTS" ]; then
                echo '[ERROR - 6.14] PostgreSQL n’est pas opérationnel après plusieurs tentatives.' | tee -a "$LOG_FILE"
                exit 1
              fi
            done
              
            docker inspect "$POSTGRES_CONTAINER_NAME" | grep -A 10 "Env"
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -c "\l"
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -c "\du"
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -c "\\l"
            docker exec "$POSTGRES_CONTAINER_NAME" psql -U "$DB_USERNAME" -c "\\du"           
            docker logs "$POSTGRES_CONTAINER_NAME"
          EOF
        # === Étape 7 : Création de la base de données et des utilisateurs ===
      - name: 7 - Création de la base de données et des utilisateurs
        run: |        
          echo "=== Étape 7 : Création de la base de données et des utilisateurs ==="
          ssh -p "$SSH_PORT" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa "$SSH_USER@$SERVER_IP" << EOF
            set -e
            echo '[INFO - Étape 7] Création des utilisateurs et de la base de données...' | tee -a "$LOG_FILE"

            # Vérification et création du rôle si absent
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USERNAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE ROLE \"$DB_USERNAME\" WITH LOGIN PASSWORD '$DB_PASSWORD';"
              echo '[INFO] Rôle créé : $DB_USERNAME' | tee -a "$LOG_FILE"
            }

            # Vérification et création de la base de données si absente
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -tc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" | grep -q 1 || {
              docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "CREATE DATABASE \"$DB_NAME\" WITH OWNER \"$DB_USERNAME\";"
              echo '[INFO] Base de données créée : $DB_NAME' | tee -a "$LOG_FILE"
            }

            # Initialisation des permissions
            docker exec -i "$POSTGRES_CONTAINER_NAME" psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USERNAME\";"
            echo '[SUCCESS] Étape 7 terminée avec succès.' | tee -a "$LOG_FILE"
          EOF

      - name: 8 - Déployer le conteneur Backend
        run: |
          ssh -p $SSH_PORT -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/git_id_rsa $SSH_USER@$SERVER_IP "
          set -e
          echo '===================================' | tee -a $LOG_FILE
          echo '[INFO - Étape 8.1] Début du déploiement du backend...' | tee -a $LOG_FILE

          # 8.2 - Vérification des variables d'environnement
          echo '[INFO - Étape 8.2] Vérification des variables d'environnement...' | tee -a $LOG_FILE
          DATABASE_URL=\"postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT_INT/$DB_NAME\"
          MANDATORY_VARS=(ENV DB_NAME DB_USERNAME DB_PASSWORD DB_HOST DATABASE_URL MOUNT_PATH CONTAINER_NAME DB_PORT_INT DB_PORT_EXT BACKEND_PORT NETWORK JWT_SECRET)
          for VAR in \"${MANDATORY_VARS[@]}\"; do
            if [ -z \"\${!VAR}\" ]; then
              echo \"[ERROR] La variable $VAR est manquante ou vide.\" | tee -a $LOG_FILE
              exit 1
            fi
            echo \"[INFO] $VAR=\${!VAR}\" | tee -a $LOG_FILE
          done

          # Étape 8.3 - Création dynamique du fichier .env
          echo '[INFO - Étape 8.3] Création dynamique du fichier .env...' | tee -a $LOG_FILE
          cat <<EOF > $MOUNT_PATH/.env
          DATABASE_URL=$DATABASE_URL
          NODE_ENV=$ENV
          JWT_SECRET=$JWT_SECRET
          SERVER_PORT=$BACKEND_PORT
          EOF

          if [ -f \"$MOUNT_PATH/.env\" ]; then
            echo '[INFO] Fichier .env créé avec succès.' | tee -a $LOG_FILE
          else
            echo '[ERROR] Échec de la création du fichier .env.' | tee -a $LOG_FILE
            exit 1
          fi

          # Étape 8.4 - Suppression de l'ancien conteneur si nécessaire
          echo '[INFO - Étape 8.4] Vérification et suppression de l’ancien conteneur...' | tee -a $LOG_FILE
          if docker ps -a --filter \"name=$CONTAINER_NAME\" --format '{{.Names}}' | grep -w $CONTAINER_NAME; then
            echo '[INFO] Suppression de l’ancien conteneur : $CONTAINER_NAME' | tee -a $LOG_FILE
            docker stop $CONTAINER_NAME
            docker rm $CONTAINER_NAME
          fi

          # Étape 8.5 - Lancer un nouveau conteneur backend
          echo '[INFO - Étape 8.5] Lancement du conteneur backend...' | tee -a $LOG_FILE
          docker run -d --name $CONTAINER_NAME \
            --network $NETWORK \
            -v $MOUNT_PATH:/app \
            -w /app \
            -p $BACKEND_PORT:$BACKEND_PORT \
            $DOCKER_NAME || { echo '[ERROR] Échec du démarrage du conteneur.' | tee -a $LOG_FILE; exit 1; }

          echo '[SUCCESS - Étape 8] Déploiement terminé avec succès.' | tee -a $LOG_FILE
          " | tee -a $LOG_FILE

      # Étape 9 - Configurer l'URL Git distante
      - name: 9 - Configurer l'URL Git distante
        run: git remote set-url origin ${{ secrets.GIT_REPO_URL }}

      # Étape 10 - Nettoyage des fichiers temporaires
      - name: Nettoyer les fichiers temporaires
        run: rm -f /tmp/git_id_rsa